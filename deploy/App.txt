<!DOCTYPE html>
<html>
<head>
    <title>TS Time In State - 0.2.5</title>
    <!--  (c) 2020 Custom Agile.  All Rights Reserved. -->
    <!--  Build Date: Wed Jul 01 2020 14:39:39 GMT-0400 (Eastern Daylight Time) -->
    <!--  Repository: https://github.com/CustomAgile/r-time-in-state -->
    <script type="text/javascript">
        var APP_BUILD_DATE = "Wed Jul 01 2020 14:39:39 GMT-0400 (Eastern Daylight Time)";
        var CHECKSUM = 919429600667;
    </script>
    
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
Ext.define('CA.technicalservices.userutilities.FieldPicker', {
    alias: 'widget.tsfieldpickerbutton',
    extend: 'Rally.ui.Button',
    requires: [
        'Rally.ui.popover.Popover',
        'Rally.ui.Button',
        'Rally.ui.picker.FieldPicker',
        'Ext.state.Manager'
    ],
    toolTipConfig: {
        html: 'Show Columns',
        anchor: 'top'
    },
    iconCls: 'icon-add-column',

    cls: 'field-picker-btn secondary rly-small',

    alwaysSelectedValues: ['FormattedID', 'Name'], // DragAndDropRank gets added in init if Drag and Drop is enabled for the workspace in the component's context

    fieldBlackList: [],

    fieldPickerConfig: {},

    buttonConfig: {},

    modelNames: ['User'],

    rankingEnabled: false,

    //This does not show the Rank column

    constructor: function(config) {
        this.config = _.merge({}, this.config || {}, config || {});
        this.callParent([config]);
    },

    initComponent: function() {

        if (this.models) {
            this.on('click', this._createPopover, this);
            this.callParent(arguments);
            return;
        }

        if (this.context && this.modelNames && this.modelNames.length > 0) {
            Rally.data.ModelFactory.getModels({
                types: this.modelNames,
                context: this.context,
                success: function(models) {
                    this.models = models;
                },
                failure: function(failedParam) {
                    console.log('failedparam');
                },
                scope: this
            });
            this.on('click', this._createPopover, this);
        }
        else {
            this.iconCls = 'icon-none';
            var msg = "Please update the CA.technicalservices.FieldPicker configuration with modelNames and context";
            this.toolTipConfig = {
                html: '<div style="color:red;">' + msg + '</div>'
            };
            this.on('click', function() { Rally.ui.notify.Notifier.showError({ message: msg }); });
        }
        this.callParent(arguments);
    },
    getFields: function() {
        return _.union(this._fields || [], this.alwaysSelectedValues);
    },
    _getPickerConfig: function() {
        var pickerConfig;
        pickerConfig = _.extend({
            value: this._fields,
            fieldBlackList: this.fieldBlackList,
            alwaysSelectedValues: this.alwaysSelectedValues,
            context: this.context
        }, this.fieldPickerConfig);

        return pickerConfig;
    },

    _createPopover: function(btn) {
        var popoverTarget = btn.getEl();

        this.popover = Ext.create('Rally.ui.popover.Popover', {
            target: popoverTarget,
            placement: ['bottom', 'left', 'top', 'right'],
            cls: 'field-picker-popover',
            toFront: Ext.emptyFn,
            buttonAlign: 'center',
            title: this.getTitle(),
            listeners: {
                destroy: function() {
                    this.popover = null;
                },
                scope: this
            },
            buttons: [{
                    xtype: "rallybutton",
                    text: 'Apply',
                    cls: 'field-picker-apply-btn primary rly-small',
                    listeners: {
                        click: function() {
                            this._onApply(this.popover);
                        },
                        scope: this
                    }
                },
                {
                    xtype: "rallybutton",
                    text: 'Cancel',
                    cls: 'field-picker-cancel-btn secondary dark rly-small',
                    listeners: {
                        click: function() {
                            this.popover.close();
                        },
                        scope: this
                    }
                }
            ],
            items: [
                _.extend({
                    xtype: 'rallyfieldpicker',
                    cls: 'field-picker',
                    itemId: 'fieldpicker',
                    modelTypes: this._getModelTypes(),
                    alwaysExpanded: true,
                    width: 200,
                    emptyText: 'Search',
                    selectedTextLabel: 'Selected',
                    availableTextLabel: 'Available',
                    listeners: {
                        specialkey: function(field, e) {
                            if (e.getKey() === e.ESC) {
                                this.popover.close();
                            }
                        },
                        scope: this
                    }
                }, this._getPickerConfig())
            ]
        });
    },

    _getModelTypes: function() {
        return _.pluck(this._getModels(), 'typePath');
    },

    _getModels: function() {
        return _.reduce(this.models, function(accum, model) {
            if (model.typePath === 'artifact') {
                accum = accum.concat(model.getArtifactComponentModels());
            }
            else {
                accum.push(model);
            }
            return accum;
        }, []);
    },

    getTitle: function() {
        return 'Show Columns';
    },

    /**
     * Update the fields displayed. In grid mode this will be the columns displayed. In board mode it will be
     * the fields on the cards
     *
     * @param {String[]|Object[]} fields A list of field names to display
     * @param {Boolean} true to suspend store load if it will be triggered elsewhere
     */
    updateFields: function(fields, suspendLoad) {
        this._fields = fields;
        if (this.popover && this.popover.down('rallyfieldpicker')) {
            this.popover.down('rallyfieldpicker').setValue(fields.join(','));
        }
        this.saveState();
    },
    getState: function() {
        return {
            fields: this._fields
        };
    },
    applyState: function(state) {
        if (state) {
            this._fields = state.fields;
        }
    },
    _onApply: function(popover) {
        var fieldPicker = popover.down('rallyfieldpicker'),
            fields = _.map(fieldPicker.getValue(), function(field) {
                return field.get('name');
            });

        this.updateFields(fields);
        popover.close();

        this.fireEvent('fieldsupdated', fields);
    }
});

Ext.override(Rally.ui.inlinefilter.FilterFieldFactory, {
    _getBaseEditorConfig: function (fieldDef, context) {
        if (fieldDef.name === "CreatedBy") {
            let editorConfig = {
                xtype: "rallyusersearchcombobox",
                fieldLabel: fieldDef.displayName,
                allowNoEntry: false,
                valueField: '_uuidRef',
                storeConfig: {
                    models: [fieldDef.attributeDefinition.AllowedValueType._refObjectName],
                    context: {
                        workspace: context.getDataContext().workspace,
                        project: null
                    }
                }
            };

            return editorConfig;
        }

        return this.callParent(arguments);
    }
});

Ext.override(Rally.ui.inlinefilter.InlineFilterPanel, {
    // We don't want chevrons in the tab panel
    _alignChevron: function () {
        if (this.chevron) { this.chevron.hide(); }
    },

    // Don't create the close buttons
    _createCloseButton: function () { }
});

Ext.override(Ext.form.field.ComboBox, {
    select: function (r) {
        if (r && !r.get('ObjectID') && r.get('_uuidRef') === '/allowedattributevalue/') {
            return;
        }
        this.callParent(arguments);
    }
});

Ext.override(Rally.ui.inlinefilter.QuickFilterPanel, {
    getFilters: function () {
        var filters = [];
        _.each(this.fields, function (field, index) {
            if (field.name === 'ModelType') {
                return;
            }

            if (!Ext.isEmpty(field.lastValue) && !field.hasActiveError()) {

                var lastValue = field.lastValue;

                var isRefUri = Rally.util.Ref.isRefUri(lastValue);
                var isRefOid = _.isNumber(Rally.util.Ref.getOidFromRef(lastValue));
                if (isRefUri && isRefOid && field.valueField === '_ref' && field.noEntryValue !== lastValue) {
                    var record = field.getRecord();
                    if (record) {
                        var uuidRef = record.get('_uuidRef');
                        if (uuidRef) {
                            lastValue = uuidRef;
                        }
                    }
                }

                var filter = _.isFunction(field.getFilter) ? field.getFilter() : Rally.data.wsapi.Filter.fromExtFilter({
                    property: field.name,
                    operator: field.operator,
                    value: lastValue
                });

                if (filter && filter.value !== '/allowedattributevalue/') {

                    if (field.allowNoEntry && field.noEntryValue === lastValue) {
                        filter.value = null;
                    }

                    Ext.apply(filter, {
                        name: field.name,
                        rawValue: lastValue,
                        filterIndex: index + 1
                    });

                    filters.push(filter);
                }
            }
        }, this);
        return filters;
    }
});
Ext.define('CustomAgile.multilevelfilter.ToggleButton', {
    extend: 'Rally.ui.Button',
    alias: 'widget.multifiltertogglebtn',

    stateful: true,

    config: {
        iconCls: 'icon-filter'
    },

    constructor: function (config) {
        this.mergeConfig(config);
        this.callParent([this.config]);
    },

    getState: function () {
        return {
            filtersHidden: this.filtersHidden
        };
    },

    setFiltersHidden: function (filtersHidden) {
        this.filtersHidden = filtersHidden;
        this.saveState();
    }
});
Ext.define('CustomAgile.ui.tutorial.MultiLevelFilterTutorial', {
    singleton: true,

    welcomeHtml: `
        <h3>This component enables filters to be applied to user stories and all levels within the portfolio item hierarchy, regardless of the artifact 
        type displayed in the app.</h3>

        <h3><b>Note:</b> For grid apps that allow expanding individual rows to see child artifacts, these filters are only applied to the top-level artifact type. 
        Child artifacts will not be filtered.</h3>
    `,

    defaultOffset: [
        { x: 0, y: 0 },
        { x: 0, y: 0 },
        { x: 0, y: 0 },
        { x: 0, y: 0 }
    ],

    defaultChevronOffset: [
        { x: 0, y: -14 },
        { x: 14, y: 0 },
        { x: 0, y: 14 },
        { x: -8, y: 0 }
    ],

    showWelcomeDialog: function (app) {
        this.app = app;
        this.steps = this.getSteps();

        if (this.app.showFiltersBtn && this.app.showFiltersBtn.filtersHidden) {
            this.app._toggleFilters(this.app.showFiltersBtn);
        }

        let appHeight = Rally.getApp().getHeight() - 25;

        this.welcomeDialog = Ext.create('Rally.ui.dialog.Dialog', {
            autoShow: true,
            layout: 'fit',
            componentCls: 'rly-popover dark-container',
            width: 500,
            height: appHeight < 300 ? appHeight : 300,
            closable: true,
            autoDestroy: true,
            buttonAlign: 'center',
            autoScroll: true,
            title: 'Using the Multi-Level Filter',
            items: {
                xtype: 'component',
                html: this.welcomeHtml,
                padding: 10,
                style: 'font-size:12px;'
            },
            buttons: [
                {
                    xtype: "rallybutton",
                    text: 'Close',
                    cls: 'secondary rly-small',
                    listeners: {
                        click: () => {
                            this.welcomeDialog.close();
                        },
                        scope: this
                    }
                }, {
                    xtype: "rallybutton",
                    text: 'Next',
                    cls: 'primary rly-small',
                    listeners: {
                        click: function () {
                            this.showNextStep(0);
                            this.welcomeDialog.close();
                        },
                        scope: this
                    }
                }
            ]
        });
    },

    showNextStep: function (stepIndex) {
        if (this.popover) {
            Ext.destroy(this.popover);
        }

        if (stepIndex >= this.steps.length) {
            return;
        }

        if (stepIndex === -1) {
            this.showWelcomeDialog(this.app);
            return;
        }

        let currentStep = this.steps[stepIndex];

        if (currentStep.handler) {
            currentStep.handler();
        }

        let buttons = [{
            xtype: "rallybutton",
            text: 'Close',
            cls: 'secondary rly-small',
            listeners: {
                click: () => {
                    this.popover.close();
                },
                scope: this
            }
        }];

        buttons.push({
            xtype: "rallybutton",
            text: 'Previous',
            cls: 'primary rly-small',
            listeners: {
                click: function () {
                    this.showNextStep(stepIndex - 1);
                },
                scope: this
            }
        });

        if (stepIndex < this.steps.length - 1) {
            buttons.push({
                xtype: "rallybutton",
                text: 'Next',
                cls: 'primary rly-small',
                listeners: {
                    click: function () {
                        this.showNextStep(stepIndex + 1);
                    },
                    scope: this
                }
            });
        }

        let appHeight = Rally.getApp().getHeight() - 25;

        this.popover = Ext.create('Rally.ui.popover.Popover', {
            target: Rally.getApp().down(currentStep.target).getEl(),
            placement: currentStep.placement || ['bottom', 'left', 'top', 'right'],
            chevronOffset: currentStep.chevronOffset || this.defaultChevronOffset,
            offsetFromTarget: currentStep.offset || this.defaultOffset,
            overflowY: 'auto',
            maxWidth: 550,
            maxHeight: appHeight < 700 ? appHeight : 700,
            toFront: Ext.emptyFn,
            buttonAlign: 'center',
            title: currentStep.title,
            listeners: {
                destroy: function () {
                    this.popover = null;
                },
                scope: this
            },
            html: `<div class="tutorial-popover-body">${currentStep.html}</div>`,
            buttons
        });
    },

    getSteps: function () {
        let steps = [];

        if (this.app.publisher) {
            steps.push({
                target: '#pubSubIndicatorArea',
                placement: 'right',
                title: 'Broadcaster Indicator',
                offset: [
                    { x: 0, y: 0 },
                    { x: 0, y: 0 },
                    { x: 14, y: 0 },
                    { x: 0, y: 0 }
                ],
                chevronOffset: [
                    { x: 0, y: -14 },
                    { x: 14, y: -40 },
                    { x: 0, y: 14 },
                    { x: -8, y: 0 }
                ],
                html: `
           <p><span class="icon-bullhorn icon-large"></span> This bullhorn icon indicates that the app is broadcasting the selected filters to any apps on the page
         that are listening for filter changes.</p>
            `
            });
        }

        if (this.app._showAncestorFilter()) {
            steps.push({
                target: '#ancestorFilterArea',
                placement: 'bottom',
                title: 'Ancestor Filter',
                html: `
         <p>The ancestor filter allows you to filter the data to show only artifacts that are descendants of the selected artifact. 
         Use the PI Type dropdown to choose which type of Portfolio Item you want the ancestor artifact to be.</p> 
            `
            });
        }

        if (this.app._showIgnoreProjectScopeControl()) {
            let scopeOffsetX = this.app._showAncestorFilter() ? 0 : -250;
            steps.push({
                target: '#ignoreScopeControl',
                placement: 'bottom',
                title: 'Scope Control',
                offset: [
                    { x: 0, y: 0 },
                    { x: 0, y: 0 },
                    { x: 0, y: 15 },
                    { x: 0, y: 0 }
                ],
                chevronOffset: [
                    { x: 0, y: -14 },
                    { x: 14, y: 0 },
                    { x: scopeOffsetX, y: 14 },
                    { x: -8, y: 0 }
                ],
                html: `
           <p>This dropdown controls whether the filters and resulting data will be scoped to the current project (Obeying the user's 
        Project Scope Down and Project Scope Up settings) or scoped across all projects within the workspace.</p>
        <p>Depending upon the app and the filters, scoping across all projects may result in performance issues or timeout errors from the server. To ensure 
        timely performance, use filters that will return a manageable number of results.</p>
            `
            });
        }

        let buttonOffsetX = !this.app._showAncestorFilter() && !this.app._showIgnoreProjectScopeControl() ? -225 : 0;

        steps.push({
            target: 'multifiltertogglebtn',
            placement: 'bottom',
            title: 'Hide/Clear/Apply Filter Buttons',
            offset: [
                { x: 0, y: 0 },
                { x: 0, y: 0 },
                { x: 0, y: 14 },
                { x: 0, y: 0 }
            ],
            chevronOffset: [
                { x: 0, y: -14 },
                { x: 14, y: 0 },
                { x: buttonOffsetX, y: 14 },
                { x: -8, y: 0 }
            ],
            html: `
           <ul class="filter-help-list">
        <li><b>Show/Hide Filters: </b>Used to toggle the visibility of the filter controls. Use this to hide the filters if they're 
        not needed or more space is needed within the app</li>
        
        <li><b>Clear Filters: </b>Once at least 1 filter is applied, this button will appear. This button will clear all of the quick filters and advanced filters across all artifact types. 
        Upon clearing the filters, the app will refresh its data.</li>
        
        <li><b>Apply Filters: </b>If present, this button becomes active after a single change is made to one of the filters. This button 
        allows the user to make multiple changes without the app refreshing after each change. Once the user has modified all of 
        the necessary filters, clicking this button will apply it to the app and refresh the data. If this button is not present, 
        the app will refresh after each change made to the filters.</li>
        </ul>
            `
        },
            {
                target: '#multiLevelFilterTabPanel tabbar tab',
                placement: 'bottom',
                title: 'Artifact Type Tabs',
                offset: [
                    { x: 0, y: 0 },
                    { x: 0, y: 0 },
                    { x: 0, y: 14 },
                    { x: 0, y: 0 }
                ],
                chevronOffset: [
                    { x: 0, y: -14 },
                    { x: 14, y: 0 },
                    { x: -25, y: 14 },
                    { x: -8, y: 0 }
                ],
                html: `
           <p>Each tab contains a unique filter that will apply filters at the level of the specified artifact type. 
        If the tab title ends with a number in parenthesis, this indicates the current number of filters applied at that level.</p>
            `
            },
            {
                target: '#' + this.app.btnRenderAreaId,
                placement: 'bottom',
                title: 'Errors',
                chevronOffset: [
                    { x: 0, y: -14 },
                    { x: 14, y: 0 },
                    { x: 0, y: 28 },
                    { x: -8, y: 0 }
                ],
                html: `
            <h4><i>One of the filters is trying to return too many records and would result in timeouts...</i></h4>
        <ul>
        <li>Often times, when using filters on artifact types above or below the artifact type displayed within the app, it's necessary 
        to first fetch those artifacts at that level in order to properly apply the filters. If the number of artifacts fitting those 
        filters is too large, it's too slow or impossible to retrieve all of them in order to then use them as filters afterwards.
        <br><br>
        <b>Example: </b>
        Using a grid to display Features across all projects. We only want to see Features that have User Stories that are blocked. 
        Since there's no way to directly search for Features containing blocked stories, we must first find all blocked stories so we can 
        build a list of Features that are tied to those stories. And since we're scoping across all projects, we must query for all blocked 
        stories across the workspace. The results would be over ten thousand records, which would take very long to load, or would fail 
        to load due to timeout errors. This is an example of when we would see this error. Using more specific filters, or scoping to a specific 
        project hierarchy would solve this issue.
        </li>
        </ul>
            `
            });

        return steps;
    }
});
Ext.define('Utils.AncestorPiAppFilter', {
    alias: 'plugin.UtilsAncestorPiAppFilter',
    version: "1.3.4",
    mixins: [
        'Ext.AbstractPlugin',
        'Rally.Messageable'
    ],
    extend: 'Ext.Component',

    statics: {
        RENDER_AREA_ID: 'utils-ancestor-pi-app-filter',
        PANEL_RENDER_AREA_ID: 'multi-level-pi-app-filter-panel'
    },

    config: {
        /**
         * @cfg {Boolean}
         * The id of the component where the plugin will render its controls
         */
        renderAreaId: 'utils-ancestor-pi-app-filter',

        /**
         * @cfg {String}
         * The id of the component where the filter button will render itself
         */
        btnRenderAreaId: 'utils-ancestor-pi-app-filter',

        /**
         * @cfg {String}
         * The id of the component where the tabbed filter panel will render itself
         */
        panelRenderAreaId: 'multi-level-pi-app-filter-panel',

        /**
         * @cfg {Boolean}
         * Set to true to show multilevel filter by default
         */
        displayMultiLevelFilter: false,

        /**
         * @cfg {String}
         * Choose default setting for project scope
         * Possible values: current, workspace, user
         */
        projectScope: 'user',

        /**
         * @cfg {Boolean}
         * Set to true to indicate that this component is a publisher of events
         * to other apps using this plugin
         */
        publisher: false,

        /**
         * @cfg {Boolean}
         * Set to false to prevent the '-- None --' selection option if your app can't support
         * querying by a null ancestor (e.g. Lookback _ItemHierarchy)
         */
        allowNoEntry: true,

        /**
         * @cfg {Object}
         * Config applied to the app settings components
         */
        settingsConfig: {},

        /**
         * @cfg {Object}
         * Fetch list for PI Selector
         */
        defaultFetch: true,

        /**
         * @cfg {Array}
         * Whitelist array for inline filters. Used if app fails to retrieve global
         * whitelist or overrideGlobalWhitelist is set to true
         */
        whiteListFields: ['Tags', 'Milestones', 'c_EAEpic', 'c_EnterpriseApprovalEA', 'DisplayColor'],

        /**
         * @cfg {Boolean}
         * Set to true to specify custom whitelist array
         */
        overrideGlobalWhitelist: false,

        /**
         * @cfg {Array}
         * Blacklist array for inline filters
         */
        blackListFields: [],

        /**
         * @cfg {Boolean}
         * Setting for inlineFilterButtonConfig
         */
        filterChildren: false,

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker
         */
        ancestorLabel: 'With ancestor',

        /**
         * @cfg {Number}
         * Width of the Portfolio Item Type picker label
         */
        ancestorLabelWidth: 110,

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker when shown with the ancestor filter
         */
        ownerLabel: 'and owned by',

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker when shown by itself
         */
        ownerOnlyLabel: 'Owned by',

        /**
         * @cfg {Number}
         * Width of the Portfolio Item Type picker label
         */
        ownerLabelWidth: 110,


        /**
         * @cfg {Number}
         * Style of the Portfolio Item Type picker label
         */
        labelStyle: 'font-size: medium',

        /**
         * @cfg {Number}
         * Minimum width for single row layout
         */
        singleRowMinWidth: 840,

        /**
         * @cfg {Array}
         * Field list for multi-level filter panel
         */
        defaultFilterFields: [],

        /**
         * @cfg {Boolean}
         * Set to true to hide filters on load
         */
        filtersHidden: false,

        /**
         * @cfg {Boolean}
         * Set to true to hide advanced filters on load
         */
        advancedFilterCollapsed: false,
        /**
         * @cfg {String}
         * Pass a typePath to set that PI type as the default visible tab
         */
        visibleTab: undefined,

        /**
         * @cfg {Boolean}
         * Set to true to prevent user from scoping app across the workspace
         * */
        disableGlobalScope: false
    },
    filterControls: [],
    portfolioItemTypes: [],
    readyDeferred: null,
    piTypesDeferred: null,
    isSubscriber: false,
    changeSubscribers: [],
    publishedValue: {},
    defaultTab: 0,

    constructor: function () {
        this.callParent(arguments);
        // this._addCancelLoad(); TODO - Future work
        this._setupPubSub();
        Ext.tip.QuickTipManager.init();
    },

    initComponent: function () {
        this.callParent(arguments);
        this.addEvents('ready', 'select', 'change');
    },

    init: function (cmp) {
        this.cmp = cmp;
        this.cmp.on('resize', this._onCmpResize, this);
        this.renderArea = this.cmp.down('#' + this.renderAreaId);
        this.btnRenderArea = this.cmp.down('#' + this.btnRenderAreaId);
        this.panelRenderArea = this.cmp.down('#' + this.panelRenderAreaId);

        // Extend app settings fields
        var cmpGetSettingsFields = this.cmp.getSettingsFields;
        this.cmp.getSettingsFields = function () {
            return this._getSettingsFields(cmpGetSettingsFields.apply(cmp, arguments));
        }.bind(this);

        // Extend app default settings fields
        var appDefaults = this.cmp.defaultSettings;
        appDefaults['Utils.AncestorPiAppFilter.enableAncestorPiFilter2'] = false;
        appDefaults['Utils.AncestorPiAppFilter.projectScope'] = this.projectScope;
        appDefaults['Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter'] = this.displayMultiLevelFilter;
        this.cmp.setDefaultSettings(appDefaults);

        // Add the control components then fire ready
        this._getGlobalWhitelist().then({
            scope: this,
            success: function (whitelist) {
                this.whiteListFields = whitelist;

                this._getTypeDefinitions().then({
                    scope: this,
                    success: function () {
                        Promise.all([this._addAncestorControls(), this._addFilters()]).then(
                            function () {
                                setTimeout(function () { this._setReady(); }.bind(this), 500);
                            }.bind(this),
                            function (error) {
                                this._showError(error, 'Failed while adding ancestor and multilevel filters');
                                this._setReady();
                            }.bind(this)
                        );
                    },
                    failure: function () {
                        this._showError('Failed to fetch portfolio item types for multi-level filter');
                    }
                });
            }
        });
    },

    // Attempt to load preference object specifying list of fields to whitelist
    _getGlobalWhitelist: function () {
        let def = Ext.create('Deft.Deferred');
        let prefName = 'multi-level-filter-whitelist-fields-preference-' + this.cmp.getContext().getWorkspaceRef();
        if (this.overrideGlobalWhitelist) {
            def.resolve(this.whiteListFields);
            return def.promise;
        }

        Rally.data.PreferenceManager.load({
            filterByName: prefName,
            scope: this,
            success: function (pref) {
                if (pref && pref.hasOwnProperty(prefName)) {
                    try {
                        let fields = pref[prefName].split(',');
                        if (fields && fields.length) {
                            def.resolve(fields);
                        }
                        else {
                            def.resolve(this.whiteListFields);
                        }
                    }
                    catch (e) {
                        def.resolve(this.whiteListFields);
                    }
                }
                else {
                    def.resolve(this.whiteListFields);
                }
            }
        });
        return def.promise;
    },

    _getTypeDefinitions: function () {
        let def = Ext.create('Deft.Deferred');

        Rally.data.util.PortfolioItemHelper.getPortfolioItemTypes().then({
            scope: this,
            success: function (piTypes) {
                this.portfolioItemTypes = piTypes;

                Ext.create('Rally.data.wsapi.Store', {
                    model: Ext.identityFn('TypeDefinition'),
                    fetch: ['Name', 'Ordinal', 'TypePath'],
                    requester: this,
                    filters: [{ property: 'Name', value: 'Hierarchical Requirement' }]
                }).load({
                    scope: this,
                    callback: function (records, operation, success) {
                        if (success) {
                            if (records && records.length) {
                                this.storyType = records[0];
                                this.allTypes = [this.storyType].concat(this.portfolioItemTypes);
                                def.resolve();
                            }
                            else { def.reject(); }
                        }
                        else { def.reject(); }
                    }
                });
            },
            failure: function () {
                def.reject();
            }
        });

        return def.promise;
    },

    notifySubscribers: function (changeType) {
        var data = this._getValue();
        data.changeType = changeType;
        _.each(this.changeSubscribers, function (subscriberName) {
            this.publish(subscriberName, data);
        }, this);
    },

    // Returns a filter that will ensure results are children of the
    // selected ancestor portfolio item. type is the TypeDefinition 
    // for the Portfolio Item level you wish to fetch.
    getAncestorFilterForType: function (type) {
        var filter;
        var modelName = type.toLowerCase();
        var currentValues = this._getValue();

        if (currentValues.piTypePath) {
            var selectedPiTypePath = currentValues.piTypePath;
            var selectedRecord = currentValues.isPiSelected;
            var selectedPi = currentValues.pi;
            var typesAbove = this._getAncestorTypeArray(modelName, selectedPiTypePath);
            if (selectedRecord && selectedPi !== null && typesAbove !== null) {
                var property = this._getPropertyPrefix(modelName, typesAbove);
                if (property) {
                    filter = new Rally.data.wsapi.Filter({
                        property: property,
                        value: selectedPi
                    });
                }
            }
            else if (selectedPi !== null) {
                // Filter out any items of this type because the ancestor pi filter is
                // enabled, but this type doesn't have any pi ancestor types
                filter = new Rally.data.wsapi.Filter({
                    property: 'ObjectID',
                    value: 0
                });
            }
        }
        return filter;
    },

    // Returns an array containing all of the filters applied in the
    // multi-level filter as well as the selected ancestor PI if one is selected. 
    // type is the TypeDefinition.TypePath for the Portfolio Item level you wish to fetch.
    getAllFiltersForType: async function (type, includeFiltersBelowType) {
        let ancestorFilter = this.getAncestorFilterForType(type);
        let filters = ancestorFilter ? [ancestorFilter] : [];
        let multiFilters = await this.getMultiLevelFiltersForType(type, includeFiltersBelowType);
        filters = filters.concat(multiFilters);

        return filters;
    },

    // Returns an array containing all of the filters applied in the multi-level filter for a given PI type. 
    // Type is the TypeDefinition.TypePath for the Portfolio Item level you wish to fetch.
    getMultiLevelFiltersForType: async function (type, includeFiltersBelowType) {
        let filters = [];
        let modelName = type.toLowerCase();
        let multiLevelFilters = this.getMultiLevelFilters();

        if (!multiLevelFilters || !Object.keys(multiLevelFilters).length) {
            return filters;
        }

        let keys = this._getAllTypePaths();
        let currentLevelIndex = _.findIndex(keys, function (currentType) {
            return currentType.toLowerCase() === modelName;
        });

        for (let i = currentLevelIndex; i < keys.length; i++) {
            let currentType = keys[i];
            let currentFilters = multiLevelFilters[currentType];

            if (currentFilters && currentFilters.length) {
                // If scoping all projects, filter releases by name instead of value
                // await this._convertReleaseFilters(currentFilters);

                // If we're at the given level, just add the filters
                if (modelName === currentType.toLowerCase()) {
                    filters = filters.concat(this._getWsapiFilter(modelName));
                }
                // If we're at a level above the given level, convert filters to fit given level
                else {
                    let parentFilters = await this._getParentFilters(modelName, currentType, currentFilters);
                    filters = filters.concat(parentFilters);
                }
            }
        }

        // If building a hierarchy from top level down, we don't need to include filters
        // below the given type (e.g. a timeline app). Otherwise if being used for an app
        // that only displays one PI type, we need to include those lower filters
        if (includeFiltersBelowType && Ext.String.startsWith(type.toLowerCase(), 'portfolioitem')) {
            let childFilters = this._getChildFiltersForType(type);
            if (childFilters) {
                filters = filters.concat(childFilters);
            }
        }

        return filters;
    },

    // Returns an array containing all of the filters applied to a specific PI level.
    // type is the TypeDefinition.TypePath for the Portfolio Item level you wish to fetch.
    getFiltersOfSingleType: async function (type) {
        return this._getWsapiFilter(type);
    },

    // Returns an object containing all of the filters applied in the multi-level
    // filter. Keys are the type definition field and the resulting values are arrays
    // of filters
    getMultiLevelFilters: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.filters || {};
        }

        var filters = {};
        if (this.filterControls) {
            _.each(this.filterControls, function (filterControl) {
                let typeName = (filterControl.inlineFilterButton.modelNames) || 'unknown';
                filters[typeName] = filterControl.inlineFilterButton.getFilters();
            });
        }
        return filters;
    },

    getMultiLevelWsapiFilters: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.wsapiFilters || {};
        }

        var filters = {};
        if (this.filterControls) {
            _.each(this.filterControls, function (filterControl) {
                let typeName = (filterControl.inlineFilterButton.modelNames) || 'unknown';
                filters[typeName] = filterControl.inlineFilterButton.getWsapiFilter();
            });
        }
        return filters;
    },

    // Return array of filters for all child levels below given type prefixed 
    // appropriately to filter at the given type
    _getChildFiltersForType: function (type) {
        let types = this._getAllTypePaths();
        let childProperty = '';
        let childFilters = [];

        let startIndex = _.findIndex(types, function (t) {
            return t.toLowerCase() === type.toLowerCase();
        });

        // Types are in order lowest to highest
        for (let i = startIndex - 1; i >= 0; i--) {
            let currentType = types[i];
            childProperty = childProperty + (childProperty.length ? '.' : '') + (currentType.toLowerCase() === 'hierarchicalrequirement' ? 'UserStories' : 'Children');
            childFilters = childFilters.concat(this._getWsapiFilter(currentType, childProperty));
        }

        return childFilters;
    },

    // Given a type, a parent type and array of parent filters, convert the filters
    // to apply to the given type
    // E.g.  (owner = /user/12345)   ->    (parent.parent.owner = /user/12345)
    _getParentFilters: async function (type, parentType, parentFilters) {
        let typesAbove = this._getAncestorTypeArray(type, parentType);

        if (typesAbove !== null) {
            let parentProperty = this._getPropertyPrefix(type, typesAbove);

            if (parentProperty) {
                let hasCustomFieldFilters = this._hasCustomFilters(parentFilters);
                let emptyFilter = [new Rally.data.wsapi.Filter({
                    property: parentProperty + '.ObjectID',
                    operator: '=',
                    value: 0
                })];

                // If filters on custom fields exist, lets get a list of IDs at that level and use those IDs as our filter
                // This is to overcome an issue with missing indices in Rally's database causing timeouts
                if (hasCustomFieldFilters && this.getIgnoreProjectScope()) {
                    let parentIDs = [];
                    try {
                        let currentLevelFilters = this._getWsapiFilter(parentType);
                        parentIDs = await new Promise(function (resolve, reject) { this._getFilteredRecords(currentLevelFilters, parentType, resolve, reject); }.bind(this)).catch((e) => {
                            this._showError(e, 'Failed while loading filters for parent artifacts');
                            return [];
                        });

                        if (parentIDs && parentIDs.length) {
                            return [new Rally.data.wsapi.Filter({
                                property: parentProperty + '.ObjectID',
                                operator: 'in',
                                value: _.map(parentIDs, function (id) { return id.get('ObjectID'); })
                            })];
                        }
                        else {
                            return emptyFilter;
                        }
                    }
                    catch (e) {
                        this._showError(e, 'Failed while loading filters for parent artifacts');
                        return emptyFilter;
                    }
                }
                else {
                    return this._getWsapiFilter(parentType, parentProperty);
                }
            }
        }
        return [];
    },

    // A user can apply a custom match condition to a set of inline filters.
    // This method returns the proper WSAPI filter object representing that
    // custom set of conditions. If parentPrefix is passed, the prefix is added to
    // the set of filters before returning
    _getWsapiFilter: function (model, parentPrefix) {
        let filter;
        if (this._isSubscriber()) {
            if (this.publishedValue.wsapiFilters) {
                for (let key in this.publishedValue.wsapiFilters) {
                    if (key.toLowerCase() === model.toLowerCase()) {
                        filter = this.publishedValue.wsapiFilters[key];
                        if (filter) {
                            filter = filter.clone();
                        }
                        break;
                    }
                }
            }
        }
        else {
            if (this.filterControls) {
                _.each(this.filterControls, function (filterControl) {
                    let typeName = filterControl.inlineFilterButton.modelNames || 'unknown';
                    if (typeName.toLowerCase() === model.toLowerCase()) {
                        filter = filterControl.inlineFilterButton.getWsapiFilter();
                        if (filter) {
                            filter = filter.clone();
                        }
                    }
                });
            }
        }

        if (filter) {
            this._updateWsapiDisplayColorFilter(filter);
            if (parentPrefix) {
                this._updateWsapiFilterWithPrefix(filter, parentPrefix);
            }
        }

        return filter ? [filter] : [];
    },

    // DisplayColor filter passes hex value as uppercase, but the web service needs
    // hex values to be lowercase in order to work properly
    _updateWsapiDisplayColorFilter: function (filter) {
        if (filter) {
            if (filter.property) {
                if (typeof filter.property === 'object') {
                    this._updateWsapiDisplayColorFilter(filter.property);
                }
            }

            if (typeof filter.value === 'object') {
                this._updateWsapiDisplayColorFilter(filter.value);
            }
            else if (typeof filter.value === 'string' && /^#[0-9a-f]{3,6}$/i.test(filter.value)) {
                filter.value = filter.value.toLowerCase();
            }
        }
    },

    // Recursively traverse through a Rally WSAPI filter and apply the given prefix to all of the values
    _updateWsapiFilterWithPrefix: function (filter, parentPrefix) {
        if (filter) {
            if (filter.property) {
                if (typeof filter.property === 'string') {
                    if (filter.config && filter.property === filter.config.property) {
                        filter.config.property = `${parentPrefix}.${filter.property}`;
                    }
                    if (filter.initialConfig && filter.property === filter.initialConfig.property) {
                        filter.initialConfig.property = `${parentPrefix}.${filter.property}`;
                    }
                    filter.property = `${parentPrefix}.${filter.property}`;
                }
                else {
                    this._updateWsapiFilterWithPrefix(filter.property, parentPrefix);
                }
            }

            if (typeof filter.value === 'object') {
                this._updateWsapiFilterWithPrefix(filter.value, parentPrefix);
            }
        }
    },

    // Rally has a hard time filtering on custom dropdown fields on parents (probably
    // not indexed) so we check to see if any are applied
    _hasCustomFilters: function (filters) {
        for (let filter of filters) {
            if (filter.property.indexOf('c_') !== -1 && typeof filter.value === 'string') {
                return true;
            }
        }
        return false;
    },

    // Takes an array of filters. If scoping across all projects, we need to update any release
    // filters to filter on the release name rather than the release value
    _convertReleaseFilters: async function (filters) {
        if (this.getIgnoreProjectScope()) {
            for (let i = 0; i < filters.length; i++) {
                if (filters[i].property === 'Release') {
                    let release = await this._getRelease(filters[i].value);
                    if (release) {
                        filters[i] = new Rally.data.wsapi.Filter({
                            property: 'Release.Name',
                            value: release.Name
                        });
                    }
                }
            }
        }
    },

    _getRelease: async function (releaseVal) {
        let deferred = Ext.create('Deft.Deferred');

        Ext.Ajax.request({
            url: Ext.String.format('/slm/webservice/v2.0{0}?fetch=Name', releaseVal),
            success(response) {
                if (response && response.responseText) {
                    let obj = Ext.JSON.decode(response.responseText);
                    if (obj && obj.Release) {
                        deferred.resolve(obj.Release);
                    }
                    else {
                        deferred.resolve(null);
                    }
                } else {
                    deferred.resolve(null);
                }
            }
        });

        return deferred.promise;
    },

    getSelectedPiRecord: function () {
        return this._getValue().piRecord;
    },

    getIgnoreProjectScope: function () {
        return !this.disableGlobalScope && this._getValue().ignoreProjectScope;
    },

    getCurrentView: function () {
        var ancestorData = this._getValue();
        // Delete piRecord to avoid recursive stack overflow error
        delete ancestorData.piRecord;
        return ancestorData;
    },

    setCurrentView: function (view) {
        let scopeControl = this.renderArea.down('#ignoreScopeControl');
        if (scopeControl && typeof view.ignoreProjectScope === 'boolean') {
            scopeControl.suspendEvents(false);
            scopeControl.setValue(view.ignoreProjectScope);
            scopeControl.resumeEvents();
        }

        this.setMultiLevelFilterStates(view.filterStates);

        if (view.piTypePath) {
            this._setPiSelector(view.piTypePath, view.pi);
        }
    },

    // Returns an object of states for all of the inline filters
    // Used for getting and setting shared views
    getMultiLevelFilterStates: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.filterStates || {};
        }

        var states = {};
        if (this.filterControls) {
            _.each(this.filterControls, function (filterControl) {
                let typeName = (filterControl.inlineFilterButton.modelNames) || 'unknown';
                states[typeName] = filterControl.inlineFilterButton.getState();
            });
        }

        return states;
    },

    getModels: function () {
        return this.models;
    },

    getPortfolioItemTypes: function () {
        return this.portfolioItemTypes;
    },

    getLowestPortfolioItemType: function () {
        return this.portfolioItemTypes[0];
    },

    // Sets the states of the inline filters
    // Used when applying a shared view to the filters
    setMultiLevelFilterStates: function (states) {
        if (!this._isSubscriber()) {
            if (states) {
                this.suspendEvents(false);
                if (this.tabPanel) {
                    this.tabPanel.removeAll();
                }
                for (let key in states) {
                    if (states.hasOwnProperty(key)) {
                        for (let i = 0; i < this.filterControls.length; i++) {
                            let typeName = (this.filterControls[i].inlineFilterButton.modelNames) || 'unknown';
                            if (typeName === key) {
                                let filterBtn = this.filterControls[i].inlineFilterButton;
                                // filterBtn.suspendEvents(false);
                                filterBtn.applyState(states[key]);
                                // filterBtn.resumeEvents();
                            }
                        }
                    }
                }
                setTimeout(function () {
                    this.resumeEvents();
                    this.tabPanel && this.tabPanel.setActiveTab(this.defaultTab);
                    this._onChange();
                }.bind(this), 1500);
            }
            else {
                this._clearAllFilters();
            }
        }
    },

    // On many apps, the multilevel filter replaces the original single inline filter
    // control. Some users have saved views containing a filter state from this original
    // filter. This method allows apps to try and apply those filters to the multilevel
    // filter at the proper level in the porfolio hierarchy
    mergeLegacyFilter: function (multiFilterStates, legacyFilterState, modelName, setState) {
        if (!this._isSubscriber() && multiFilterStates && legacyFilterState && modelName) {
            for (let multiModel in multiFilterStates) {
                if (multiFilterStates.hasOwnProperty(multiModel)) {
                    if (multiModel === modelName) {
                        try {
                            let currentState = multiFilterStates[multiModel];
                            if (legacyFilterState.matchType) {
                                currentState.matchType = legacyFilterState.matchType;
                            }
                            if (typeof legacyFilterState.condition === 'string') {
                                currentState.condition = legacyFilterState.condition;
                            }
                            if (legacyFilterState.quickFilters) {
                                if (legacyFilterState.quickFilterFields && !legacyFilterState.quickFilterFields.length) {
                                    for (let qFilter of legacyFilterState.quickFilters) {
                                        legacyFilterState.quickFilterFields.push(qFilter.name);
                                    }
                                }
                                currentState.quickFilters = _.merge(currentState.quickFilters, legacyFilterState.quickFilters);
                            }
                            if (legacyFilterState.advancedFilters) {
                                currentState.advancedFilters = _.merge(currentState.advancedFilters, legacyFilterState.advancedFilters);
                            }
                            if (legacyFilterState.quickFilterFields) {
                                currentState.quickFilterFields = _.merge(currentState.quickFilterFields, legacyFilterState.quickFilterFields);
                            }
                        }
                        catch (e) {
                            console.error('Failed to merge legacy filter into multi-level filter');
                        }
                    }
                }
            }

            if (setState) {
                this.setMultiLevelFilterStates(multiFilterStates);
            }
        }
    },

    // Returns an array of records fitting the given filters
    _getFilteredRecords: async function (filters, model, resolve, reject) {
        let dataContext = Rally.getApp().getContext().getDataContext();
        if (this.getIgnoreProjectScope()) {
            dataContext.project = null;
        }

        let ancestor = this.getAncestorFilterForType(model);
        if (ancestor && ancestor.value) {
            filters.push(ancestor);
        }

        let fetch = ['ObjectID'];
        if (model === 'HierarchicalRequirement') {
            fetch.push('Feature');
        }
        else {
            fetch.push('Parent');
        }

        let totalCount = await this._getTotalResultCount(dataContext, filters, model);

        if (totalCount === -1) {
            reject('Multi-level filter failed while filtering out items above or below selected portfolio item type.');
        }
        else if (totalCount === 0) {
            resolve([]);
        }
        else if (totalCount > 6000) {
            reject('One of the filters is trying to return too many records and would result in long load times or timeouts, try using more specific filters to reduce the total result-set.');
        }
        else {
            let store = Ext.create('Rally.data.wsapi.Store', {
                autoLoad: false,
                context: dataContext,
                filters,
                model,
                fetch,
                limit: Infinity,
                enablePostGet: true
            });

            store.load().then({
                scope: this,
                success: function (records) {
                    resolve(records);
                },
                failure: function () {
                    reject('Multi-level filter failed while filtering out items above or below selected portfolio item type. Result set was probably too large.');
                }
            });
        }
    },

    _getTotalResultCount: function (context, filters, model) {
        let deferred = Ext.create('Deft.Deferred');

        let store = Ext.create('Rally.data.wsapi.Store', {
            autoLoad: false,
            context,
            filters,
            model,
            fetch: ['_ref'],
            limit: 1,
            enablePostGet: true
        });

        store.load().then({
            scope: this,
            success: function () {
                deferred.resolve(store.totalCount);
            },
            failure: function () {
                deferred.resolve(-1);
            }
        });

        return deferred.promise;
    },

    _setupPubSub: function () {
        if (this.publisher) {
            this.subscribe(this, 'registerChangeSubscriber', function (subscriberName) {
                // Register new unique subscribers
                if (!_.contains(this.changeSubscribers, subscriberName)) {
                    this.changeSubscribers.push(subscriberName);
                }
                this.publish(subscriberName, this._getValue());
            }, this);
            // Ask any existing subscribers to re-register
            this.publish('reRegisterChangeSubscriber');
        }
        else {
            this.subscriberEventName = Rally.getApp().getAppId() + this.$className;

            // Subscribe to a channel dedicated to this app
            this.subscribe(this, this.subscriberEventName, function (data) {
                if (this.intervalTimer) {
                    clearInterval(this.intervalTimer);
                    delete this.intervalTimer;
                }
                if (!this.isSubscriber) {
                    this.isSubscriber = true;
                    this._hideControlCmp();
                }

                // We only want to refresh the app if we have all of the filters from the broadcaster
                if (data.ready) {
                    this.publishedValue = data;
                    // Default to an ancestor change event for backwards compatibility
                    if (data.changeType === 'ancestor' || !data.changeType) {
                        this._onSelect();
                    }
                    else {
                        this._onChange();
                    }
                } else {
                    setTimeout(() => { this.publish('registerChangeSubscriber', this.subscriberEventName); }, 500);
                }
            }, this);

            // Attempt to register with a publisher (if one exists)
            this.publish('registerChangeSubscriber', this.subscriberEventName);
            this.registerAttempts = 0;
            this.intervalTimer = setInterval(() => {
                this.registerAttempts++;

                // After 15 attempts, there probably isn't a broadcaster present, so delete the interval
                if (this.registerAttempts >= 15) {
                    clearInterval(this.intervalTimer);
                    delete this.intervalTimer;
                    delete this.registerAttempts;
                }
                else {
                    this.publish('registerChangeSubscriber', this.subscriberEventName);
                }
            }, 500);
            this.subscribe(this, 'reRegisterChangeSubscriber', function () {
                this.publish('registerChangeSubscriber', this.subscriberEventName);
            }, this);
        }
    },

    _getValue: function () {
        var result = {};
        if (this._isSubscriber()) {
            result = this.publishedValue || {};
        }
        else {
            if (this.piTypeSelector) {
                var selectedPiType = this.piTypeSelector.getRecord();
                if (selectedPiType && this.piSelector) {
                    var selectedPiTypePath = selectedPiType.get('TypePath');
                    var selectedRecord = this.piSelector.getRecord();
                    var selectedPi = this.piSelector.getValue();
                    _.merge(result, {
                        piTypePath: selectedPiTypePath,
                        isPiSelected: !!selectedPi,
                        pi: selectedPi,
                        piRecord: selectedRecord
                    });
                }
            }
            result.ignoreProjectScope = this._ignoreProjectScope();
            result.filters = this.getMultiLevelFilters();
            result.filterStates = this.getMultiLevelFilterStates();
            result.wsapiFilters = this.getMultiLevelWsapiFilters();
            result.ready = this.ready;
        }
        return result;
    },

    _setReady: function () {
        // Hide floating components because of course they are still visible when settings menu is shown
        this.cmp.on('beforehide', () => {
            if (this.filterHelpBtn) {
                this.filterHelpBtn.hide();
            }
        });
        this.cmp.on('beforeshow', () => {
            if (this.filterHelpBtn) {
                this.filterHelpBtn.show();
            }
        });

        if (!this._showMultiLevelFilter() && this.filterHelpBtn) {
            this.filterHelpBtn.hide();
        }

        if (this._isSubscriber()) {
            if (this.tabPanel) {
                this.tabPanel.hide();
            }

            if (this.showFiltersBtn) {
                this.showFiltersBtn.hide();
            }

            if (this.filterHelpBtn) {
                this.filterHelpBtn.hide();
            }

            if (!this.publishedValue.filters) {
                setTimeout(function () {
                    this.ready = true;
                    this.fireEvent('ready', this);
                }.bind(this), 3000);
                return;
            }
        }
        else {
            this._updateReleaseValues();
        }
        this.ready = true;
        this.fireEvent('ready', this);
    },

    // Ancestor filter dropdowns have been selected
    _onSelect: function () {
        if (this.ready) {
            this.fireEvent('select', this);
        }
    },

    // Multi-level filters have changed
    _onChange: function () {
        if (this.ready) {
            this.fireEvent('change', this.getMultiLevelFilters());
        }
    },

    hideHelpButton: function () {
        if (this.filterHelpBtn) {
            this.filterHelpBtn.hide();
        }
    },

    showHelpButton: function () {
        if (this.filterHelpBtn) {
            this.filterHelpBtn.show();
        }
    },

    _getSettingsFields: function (fields) {
        var currentSettings = Rally.getApp().getSettings();
        if (!currentSettings.hasOwnProperty('Utils.AncestorPiAppFilter.projectScope')) {
            currentSettings['Utils.AncestorPiAppFilter.projectScope'] = this.projectScope;
        }
        if (!currentSettings.hasOwnProperty('Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter')) {
            currentSettings['Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter'] = this.displayMultiLevelFilter;
        }
        var pluginSettingsFields = [{
            xtype: 'rallycheckboxfield',
            id: 'Utils.AncestorPiAppFilter.enableAncestorPiFilter2',
            name: 'Utils.AncestorPiAppFilter.enableAncestorPiFilter2',
            fieldLabel: 'Filter artifacts by ancestor portfolio item',
        }, {
            xtype: 'rallyportfolioitemtypecombobox',
            id: 'Utils.AncestorPiAppFilter.defaultPiType',
            name: 'Utils.AncestorPiAppFilter.defaultPiType',
            fieldLabel: "Default Portfolio Item type",
            valueField: 'TypePath',
            allowNoEntry: false,
            defaultSelectionPosition: 'last',
            // Disable the preference enabled combo box plugin so that this control value is app specific
            plugins: []
        },
        {
            xtype: 'radiogroup',
            fieldLabel: 'Show artifacts from',
            columns: 1,
            vertical: true,
            allowBlank: false,
            name: 'Utils.AncestorPiAppFilter.projectScope',
            items: [{
                boxLabel: "User's current project(s).",
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'current',
                checked: 'current' === currentSettings['Utils.AncestorPiAppFilter.projectScope'] || this.disableGlobalScope
            }, {
                boxLabel: "All projects in workspace.",
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'workspace',
                checked: 'workspace' === currentSettings['Utils.AncestorPiAppFilter.projectScope'] && !this.disableGlobalScope,
                disabled: this.disableGlobalScope
            }, {
                boxLabel: 'User selectable (either current project(s) or all projects in workspace).',
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'user',
                checked: 'user' === currentSettings['Utils.AncestorPiAppFilter.projectScope'] && !this.disableGlobalScope,
                disabled: this.disableGlobalScope
            },],
            listeners: {
                scope: this,
                change: function () {
                    return;
                }
            }
        },
        {
            xtype: 'rallycheckboxfield',
            id: 'Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter',
            name: 'Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter',
            fieldLabel: 'Enable multi-level portfolio item filter',
            value: currentSettings['Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter']
        }
        ];
        pluginSettingsFields = _.map(pluginSettingsFields, function (pluginSettingsField) {
            return _.merge(pluginSettingsField, this.settingsConfig);
        }, this);
        // apply any settings config to each field added by the plugin
        return pluginSettingsFields.concat(fields || []);
    },

    // When changing projects, if a release filter was previously applied, the inline filter state remembers the release
    // filter, but fails to populate the comobobox with the release name, which becomes misleading to 
    // the end user. This hack finds the release name and shoves it into the combobox.
    _updateReleaseValues: function () {
        _.each(this.filterControls, function (filter) {
            _.each(filter.inlineFilterButton.inlineFilterPanel.advancedFilterPanel.advancedFilterRows.rows, function (row) {
                if (row.name === 'Release' && row._valueFieldIsValid()) {
                    _.each(row.items.items, function (rowItem) {
                        if (rowItem.xtype === 'rallyreleasecombobox') {
                            this._getRelease(rowItem.originalValue).then(function (release) {
                                if (release) {
                                    rowItem.rawValue = release.Name;
                                }
                            });
                        }
                    }, this);
                }
            }, this);
        }, this);
    },

    // Requires that app settings are available (e.g. from 'beforelaunch')
    _addAncestorControls: function () {
        var controlsLayout = {
            type: 'hbox',
            align: 'middle',
            defaultMargins: '0 10 0 0'
        };
        var ownerLabelWidth = this.ownerLabelWidth;
        if (this.cmp.getWidth() < this.singleRowMinWidth) {
            controlsLayout = 'vbox';
            ownerLabelWidth = this.ancestorLabelWidth;
        }
        var scopeControlByItself = false;
        if (this._showAncestorFilter() === false && this._showIgnoreProjectScopeControl() === true) {
            scopeControlByItself = true;
        }
        var controls = {
            xtype: 'container',
            id: 'controlsArea',
            overflowX: 'auto',
            layout: {
                type: 'hbox',
                align: 'top'
            },
            items: [{
                xtype: 'container',
                id: 'pubSubIndicatorArea',
                width: 25,
                padding: '6 5 0 0',
                hidden: !this.publisher && !this._isSubscriber(),
                items: [{
                    xtype: 'component',
                    id: 'publisherIndicator',
                    html: '<span class="icon-bullhorn icon-large"></span>',
                    hidden: !this.publisher
                },
                {
                    xtype: 'component',
                    id: 'subscriberIndicator',
                    html: '<span class="icon-link icon-large"></span>',
                    hidden: !this._isSubscriber()
                },
                ]
            }, {
                xtype: 'container',
                id: 'filtersArea',
                layout: controlsLayout,
                items: [{
                    xtype: 'container',
                    id: 'ancestorFilterArea',
                    layout: {
                        type: 'hbox',
                        align: 'middle'
                    },
                    items: [{
                        xtype: 'container',
                        id: 'piTypeArea',
                        layout: {
                            type: 'hbox',
                            align: 'middle'
                        },
                    },
                    {
                        xtype: 'container',
                        id: 'piSelectorArea',
                        itemId: 'piSelectorArea',
                        layout: {
                            type: 'hbox',
                            align: 'middle',
                            padding: '0 0 0 5'
                        },
                    }
                    ]
                }, {
                    xtype: 'container',
                    itemId: 'scopeControlArea',
                    id: 'scopeControlArea',
                    width: this._showIgnoreProjectScopeControl() ? 250 : 0,
                    margin: this._showIgnoreProjectScopeControl() ? '0 10 0 0' : 0,
                    layout: {
                        type: 'hbox',
                        align: 'middle'
                    },
                    items: [{
                        xtype: 'rallycombobox',
                        itemId: 'ignoreScopeControl',
                        id: 'ignoreScopeControl',
                        stateful: true,
                        stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.ignoreProjectScopeControl'),
                        stateEvents: ['select'],
                        hidden: this._isSubscriber() || !this._showIgnoreProjectScopeControl(),
                        displayField: 'text',
                        valueField: 'value',
                        labelStyle: this.labelStyle,
                        labelWidth: this._showIgnoreProjectScopeControl() ? ownerLabelWidth : 0,
                        fieldLabel: scopeControlByItself ? this.ownerOnlyLabel : this.ownerLabel,
                        // Don't set initial value with this component or it will override the state
                        storeConfig: {
                            fields: ['text', 'value'],
                            data: [{
                                text: "Current Project(s)",
                                value: false
                            }, {
                                text: "Any Project",
                                value: true
                            }]
                        },
                        listeners: {
                            scope: this,
                            change: function () {
                                this._onSelect();
                            }
                        },
                    }]
                }]
            }]
        };

        if (this.renderArea) {
            // Without this, the components are clipped on narrow windows
            this.renderArea.setOverflowXY('auto', 'auto');
            this.renderArea.add(controls);
            this.filterHelpBtn = Ext.widget('rallybutton', {
                itemId: 'filterHelpBtn',
                floating: true,
                shadow: false,
                cls: 'filter-help',
                iconOnly: true,
                iconCls: 'icon-help',
                hidden: this._isSubscriber() || !this._showMultiLevelFilter(),
                handler: (...args) => this.onHelpClicked(...args)
            });
            this.filterHelpBtn.showBy(this.renderArea, 'tr-tr', [-4, 5]);
        }

        this._addTooltips();

        // Need to get pi types sorted by ordinal lowest to highest for the filter logic to work
        return new Promise(function (resolve) {
            if (!this._isSubscriber() && this._showAncestorFilter()) {
                // Now create the pi type selector
                this._addPiTypeSelector().then(function () {
                    this._addPiSelector(this.piTypeSelector.getValue(), null).then(
                        function () {
                            resolve();
                        }.bind(this)
                    );
                }.bind(this));
            }
            else {
                resolve();
            }
        }.bind(this));
    },

    _addPiTypeSelector: function (initialValue) {
        return new Promise(function (resolve) {
            this.piTypeSelector = Ext.create('Rally.ui.combobox.PortfolioItemTypeComboBox', {
                xtype: 'rallyportfolioitemtypecombobox',
                id: 'Utils.AncestorPiAppFilter.piType',
                name: 'Utils.AncestorPiAppFilter.piType',
                width: 250,
                // Disable the preference enabled combo box plugin so that this control value is app specific
                plugins: [],
                stateful: true,
                stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.piType'),
                stateEvents: ['select'],
                fieldLabel: this.ancestorLabel,
                labelWidth: this.ancestorLabelWidth,
                labelStyle: this.labelStyle,
                valueField: 'TypePath',
                value: initialValue || this._defaultPortfolioItemType(),
                allowNoEntry: false,
                defaultSelectionPosition: 'first',
                listeners: {
                    scope: this,
                    ready: function (combobox) {
                        // Unfortunately we cannot use the combobox store of PI types for our filter
                        // logic because it is sorted by ordinal from highest to lowest so that the
                        // picker options have a an order familiar to the user.

                        // Don't add the change listener until ready. This prevents us
                        // from adding and removing the pi selector multiple times during
                        // startup which causes a null ptr exception in that component
                        combobox.addListener({
                            scope: this,
                            change: this._onPiTypeChange
                        });
                        resolve();
                    }
                }
            });
            this.renderArea.down('#piTypeArea').add(this.piTypeSelector);
        }.bind(this));
    },

    _addTooltips: function () {
        Ext.tip.QuickTipManager.register({
            target: 'publisherIndicator',
            text: 'This app broadcasts filter settings to any enabled ancestor filtered apps (indicated with <span class="icon-link icon-large"></span>)',
            showDelay: 50,
            border: true
        });

        Ext.tip.QuickTipManager.register({
            target: 'subscriberIndicator',
            text: 'This app listens for filter settings from any enabled ancestor filter broadcast app (indicated with <span class="icon-bullhorn icon-large"></span>)',
            showDelay: 50,
            border: true
        });

        if (this._isSubscriber()) {
            Ext.tip.QuickTipManager.register({
                target: 'subscriberFilterIndicator',
                text: 'This app listens for filter settings from any enabled ancestor filter broadcast app (indicated with <span class="icon-bullhorn icon-large"></span>)',
                showDelay: 50,
                border: true
            });
        }
    },

    _onCmpResize: function (cmp, width) {
        var controlsLayout = {
            type: 'hbox',
            align: 'middle',
            defaultMargins: '0 10 0 0'
        };
        if (width < this.singleRowMinWidth) {
            controlsLayout = {
                type: 'vbox'
            };
        }
        var filtersArea = this.renderArea.down('#filtersArea');
        if (filtersArea) {
            var controlsArea = this.renderArea.down('#controlsArea');
            var filters = filtersArea.removeAll(false);
            var newFiltersArea = {
                xtype: 'container',
                id: 'filtersArea',
                layout: controlsLayout,
                items: filters,
                hidden: filtersArea.isHidden()
            };
            controlsArea.remove(filtersArea, false);
            controlsArea.add(newFiltersArea);
        }
    },

    _hideControlCmp: function () {
        if (this.renderArea) {
            this.renderArea.down('#pubSubIndicatorArea').show();
            this.renderArea.down('#subscriberIndicator').show();
            this.renderArea.down('#filtersArea').hide();
        }
    },

    _onPiTypeChange: function (piTypeSelector, newValue) {
        if (newValue) {
            let currentPi = this._getValue().pi;
            this._removePiSelector();
            this._addPiSelector(newValue).then(
                function () {
                    // this._setReady();
                    // If an ancestor was selected it has now been cleared, so fire select event
                    if (currentPi) {
                        this._onSelect();
                    }
                }.bind(this)
            );
        }
    },

    _removePiSelector: function () {
        this.piSelector = null;
        this.renderArea.down('#piSelectorArea').removeAll(true);
    },

    _addPiSelector: function (piType, initialValue) {
        return new Promise(function (resolve) {
            this.piSelector = Ext.create('Rally.ui.combobox.ArtifactSearchComboBox', {
                id: 'Utils.AncestorPiAppFilter.piSelector',
                width: 250,
                margin: '0 10 0 10',
                labelAlign: 'top',
                storeConfig: {
                    models: piType,
                    autoLoad: true,
                    fetch: this.defaultFetch,
                    context: {
                        project: null
                    }
                },
                queryDelay: 2000,
                typeAhead: false,
                validateOnChange: false,
                stateful: true,
                stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.piSelector'),
                stateEvents: ['select'],
                valueField: '_ref',
                allowClear: true,
                clearValue: null,
                allowNoEntry: this.allowNoEntry,
                noEntryValue: '',
                value: initialValue || null,
                // forceSelection: false,
                defaultSelectionPosition: null,
                listeners: {
                    scope: this,
                    select: function () {
                        this._onSelect();
                    },
                    ready: function () {
                        resolve();
                    }
                }
            });
            // Allow this combobox to save null state (which is default behavior of
            // stateful mixin, but for some reason was overridden in combobox)
            Ext.override(this.piSelector, {
                saveState: function () {
                    var me = this,
                        id = me.stateful && me.getStateId(),
                        hasListeners = me.hasListeners,
                        state;

                    if (id) {
                        state = me.getState() || {}; //pass along for custom interactions
                        if (!hasListeners.beforestatesave || me.fireEvent('beforestatesave', me, state) !== false) {
                            Ext.state.Manager.set(id, state);
                            if (hasListeners.statesave) {
                                me.fireEvent('statesave', me, state);
                            }
                        }
                    }
                }
            });
            this.renderArea.down('#piSelectorArea').add(this.piSelector);
        }.bind(this));
    },

    _setPiSelector: function (piType, pi) {
        return new Promise(function (resolve) {
            if (this.piTypeSelector) {
                this.piTypeSelector.suspendEvents(false);
                this.piTypeSelector.setValue(piType);
                this._removePiSelector();
                this._addPiSelector(piType, pi).then(function () {
                    this.piSelector.setValue(pi);
                    this.piTypeSelector.resumeEvents();
                    resolve();
                }.bind(this));
            }
            else {
                resolve();
            }
        }.bind(this));
    },

    _showAncestorFilter: function () {
        let enableAncestorFilter = this.cmp.getSetting('Utils.AncestorPiAppFilter.enableAncestorPiFilter2');

        if (enableAncestorFilter === undefined) {
            return false;
        }

        return enableAncestorFilter;
    },

    _showIgnoreProjectScopeControl: function () {
        let showProjectScope = this.cmp.getSetting('Utils.AncestorPiAppFilter.projectScope') === 'user';

        if (showProjectScope === undefined) {
            return this.projectScope;
        }

        return showProjectScope;
    },

    _ignoreProjectScope: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.ignoreProjectScope;
        }

        var result = false;
        if (this._showIgnoreProjectScopeControl()) {
            // If the control is shown, that values overrides the ignoreScope app setting
            result = this.renderArea.down('#ignoreScopeControl').getValue();
        }
        else if (this.cmp.getSetting('Utils.AncestorPiAppFilter.projectScope') === undefined) {
            result = this.projectScope === 'workspace';
        }
        else if (this.cmp.getSetting('Utils.AncestorPiAppFilter.projectScope') === 'workspace') {
            result = true;
        }

        return result;
    },

    _isSubscriber: function () {
        return this.isSubscriber;
    },

    _defaultPortfolioItemType: function () {
        return this.cmp.getSetting('Utils.AncestorPiAppFilter.defaultPiType');
    },

    _getPropertyPrefix: function (typeName, typesAbove) {
        let type = typeName.toLowerCase();
        let property;

        if (type === 'hierarchicalrequirement' || type === 'userstory') {
            property = this.getLowestPortfolioItemType().get('Name');
        }
        else if (type === 'defect') {
            property = 'Requirement';
            typesAbove = typesAbove.slice(1);
            if (typesAbove.length) {
                property += `.${this.getLowestPortfolioItemType().get('Name')}`;
            }
        }
        else if (Ext.String.startsWith(type, 'portfolioitem')) {
            property = 'Parent';
        }

        if (property) {
            // property already gets us to the lowest pi level above the current type
            // for each additional level, add a 'Parent' term, except for the last
            // type in the list which is the currently selected pi type ancestor
            _.forEach(typesAbove.slice(1), function () {
                property += '.Parent';
            }, this);
        }

        return property;
    },

    /**
     * Return a list of artifact types AT or below selectedPiTypePath,
     * that are an ancestor of the given modelName, or null if there are no pi type
     * ancestors for the given model.
     */
    _getAncestorTypeArray: function (modelName, selectedPiTypePath) {
        var selectedPiTypeIndex;
        var modelNamePiTypeIndex;
        var model = modelName.toLowerCase();
        var selectedModel = selectedPiTypePath.toLowerCase();

        if (model === 'defect') {
            selectedPiTypeIndex = _.findIndex(this.allTypes, function (type) {
                return type.get('TypePath').toLowerCase() === selectedModel;
            });
            return this.allTypes.slice(0, selectedPiTypeIndex + 1);
        }

        modelNamePiTypeIndex = _.findIndex(this.allTypes, function (type) {
            return type.get('TypePath').toLowerCase() === model;
        });
        selectedPiTypeIndex = _.findIndex(this.allTypes, function (type) {
            return type.get('TypePath').toLowerCase() === selectedModel;
        });

        if (modelNamePiTypeIndex < selectedPiTypeIndex) {
            // Don't include the current model pi in the list of ancestors
            // Include the selcted pi type ancestor
            return this.allTypes.slice(modelNamePiTypeIndex + 1, selectedPiTypeIndex + 1);
        }

        return null;
    },

    /*
        Multi-Level Filter functions
    */
    _showMultiLevelFilter: function () {
        let showFilters = this.cmp.getSetting('Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter');

        if (showFilters === undefined) {
            return this.displayMultiLevelFilter;
        }

        return showFilters;
    },

    _addFilters: function () {
        return new Promise(function (resolve, reject) {
            var promises = [];
            if (this._showMultiLevelFilter() && !this._isSubscriber()) {
                if (this.btnRenderArea) {
                    if (!this._isSubscriber()) {
                        this.showFiltersBtn = this.btnRenderArea.add(
                            {
                                xtype: 'multifiltertogglebtn',
                                cls: ` rly-small ${this.filtersHidden ? 'secondary' : 'primary'}`,
                                handler: this._toggleFilters,
                                scope: this,
                                stateId: this.cmp.getContext().getScopedStateId(`multi-filter-toggle-button`),
                                listeners: {
                                    scope: this,
                                    added: function (btn) {
                                        if (this.filtersHidden) {
                                            btn.setFiltersHidden(true);
                                        }

                                        if (btn.filtersHidden) {
                                            btn.setToolTipText('Show Filters');
                                        }
                                        else {
                                            btn.setToolTipText('Hide Filters');
                                        }
                                    }
                                }
                            }
                        );

                        Rally.data.ModelFactory.getModels({
                            types: this._getAllTypePaths().reverse(),
                            context: this.cmp.getContext(),
                            scope: this,
                            success: function (models) {
                                this.models = models;

                                this.tabPanel = this.panelRenderArea.add({
                                    xtype: 'tabpanel',
                                    itemId: 'multiLevelFilterTabPanel',
                                    width: '98%',
                                    cls: 'blue-tabs',
                                    minTabWidth: 100,
                                    plain: true,
                                    autoRender: true,
                                    hidden: this._isSubscriber() || this.showFiltersBtn.filtersHidden,
                                    hideMode: 'offsets',
                                    items: []
                                });

                                this.filterControls = [];
                                let clearAdvancedButtonConfig = {};
                                let matchTypeConfig = {};
                                let advancedFilterRowsFlex = 1;
                                let propertyFieldConfig = {
                                    blackListFields: this.blackListFields,
                                    whiteListFields: this.whiteListFields
                                };
                                let context = this.cmp.getContext();

                                if (this.cmp.getWidth() < this.singleRowMinWidth) {
                                    clearAdvancedButtonConfig = {
                                        text: 'Clear'
                                    };
                                    matchTypeConfig = {
                                        fieldLabel: 'Match',
                                        width: 65
                                    };
                                    propertyFieldConfig.width = 100;
                                    advancedFilterRowsFlex = 2;
                                }

                                // If a default visible tab is specified, we need to convert an
                                // artifact ordinal to a tab index
                                // Tab indices start at 0 for top-most portfolio item
                                // Artfiact ordinals start at -1 for user stories, 0 for Features, etc...
                                let ordinalLookup = {};
                                let modelLength = Object.keys(models).length;
                                if (this.visibleTab) {
                                    for (let i = 0; i < modelLength; i++) {
                                        ordinalLookup[i] = modelLength - i - 1;
                                    }
                                }

                                _.each(models, function (model, key) {
                                    if (this.visibleTab && this.visibleTab.toLowerCase() === key.toLowerCase()) {
                                        let ord = model.ordinal;
                                        if (typeof ord === 'number') {
                                            let newDefaultTab = ordinalLookup[ord + 1];
                                            if (typeof newDefaultTab === 'number') {
                                                this.defaultTab = newDefaultTab;
                                            }
                                        }
                                    }

                                    promises.push(new Promise(function (newResolve) {
                                        let filterName = `inlineFilter${key}`;
                                        this.filterControls.push(Ext.create('Rally.ui.inlinefilter.InlineFilterControl', {
                                            xtype: 'rallyinlinefiltercontrol',
                                            name: filterName,
                                            autoRender: true,
                                            itemId: filterName,
                                            context,
                                            inlineFilterButtonConfig: {
                                                stateful: true,
                                                stateId: this.cmp.getContext().getScopedStateId(`multi-${filterName}-button`),
                                                stateEvents: ['inlinefilterchange'],
                                                context: this.cmp.getContext(),
                                                modelNames: key,
                                                filterChildren: this.filterChildren,
                                                inlineFilterPanelConfig: {
                                                    autoRender: true,
                                                    name: `${filterName}-panel`,
                                                    itemId: `${filterName}-panel`,
                                                    model: model,
                                                    padding: 5,
                                                    width: '98%',
                                                    context,
                                                    quickFilterPanelConfig: {
                                                        defaultFields: this.defaultFilterFields,
                                                        addQuickFilterConfig: {
                                                            whiteListFields: this.whiteListFields,
                                                            blackListFields: this.blackListFields
                                                        }
                                                    },
                                                    advancedFilterPanelConfig: {
                                                        collapsed: this.advancedFilterCollapsed,
                                                        advancedFilterRowsConfig: {
                                                            propertyFieldConfig,
                                                            flex: advancedFilterRowsFlex
                                                        },
                                                        matchTypeConfig,
                                                        clearAdvancedButtonConfig
                                                    }
                                                },
                                                listeners: {
                                                    inlinefilterchange: this._onFilterChange,
                                                    inlinefilterready: function (panel) {
                                                        this._onFilterReady(panel);
                                                        newResolve();
                                                    },
                                                    scope: this
                                                }
                                            }
                                        }));
                                    }.bind(this)));
                                }, this);

                                Promise.all(promises).then(function () {
                                    if (!this._isSubscriber()) {
                                        this.clearAllButton = Ext.widget({
                                            xtype: 'rallybutton',
                                            itemId: 'clearAllButton',
                                            cls: 'secondary rly-small clear-all-filters-button',
                                            text: 'Clear All',
                                            margin: '3 9 3 0',
                                            hidden: !this._hasFilters(),
                                            listeners: {
                                                click: this._clearAllFilters,
                                                scope: this
                                            }
                                        });

                                        this.btnRenderArea.add(this.clearAllButton);
                                        this.tabPanel.setActiveTab(this.defaultTab);
                                        if (this.filtersHidden) {
                                            this.tabPanel.hide();
                                        }

                                        // Without this, the components are clipped on narrow windows
                                        this.btnRenderArea.setOverflowXY('auto', 'auto');
                                    }
                                    resolve();
                                }.bind(this));
                            },
                            failure: function () {
                                reject('Failed to fetch models for multi-level filter');
                            }
                        });
                    }
                    else {
                        this.btnRenderArea.add({
                            xtype: 'container',
                            id: 'filterSubIndicatorArea',
                            width: 25,
                            padding: '6 5 0 0',
                            items: [
                                {
                                    xtype: 'component',
                                    id: 'subscriberFilterIndicator',
                                    html: '<span class="icon-link icon-large"></span>'
                                }
                            ]
                        });
                        resolve();
                    }
                } else {
                    reject('Unable to find button render area for multi-level filter');
                }
            }
            else {
                resolve();
            }
        }.bind(this));
    },

    _clearAllFilters: function () {
        this.suspendEvents(false);

        // The quick filters don't properly clear if the filter isn't displayed
        let activeTab = this.tabPanel.getActiveTab();

        _.each(this.filterControls, function (filterControl) {
            try {
                this.tabPanel.setActiveTab(filterControl.tab);
                filterControl.inlineFilterButton.suspendEvents(false);
                filterControl.inlineFilterButton.clearAllFilters();
                filterControl.inlineFilterButton.saveState();
                filterControl.inlineFilterButton.resumeEvents();
            }
            catch (e) {
                console.log(e);
            }
        }.bind(this));

        this.tabPanel.setActiveTab(activeTab);
        this.resumeEvents();
        this._onFilterChange();
    },

    _hasFilters: function () {
        var filters = this.getMultiLevelFilters();
        var returnVal = false;

        _.each(filters, function (filter) {
            if (filter.length) {
                returnVal = true;
            }
        });

        return returnVal;
    },

    _onFilterReady: function (panel) {
        panel.expand();
        let filterCount = panel.quickFilterPanel.getFilters().length + panel.advancedFilterPanel.getFilters().length;
        let modelName = this._getModelName(panel);

        let tab = this.tabPanel.add({
            title: modelName + (filterCount ? ` (${filterCount})` : ''),
            html: '',
            itemId: `${modelName.replace(/\s+/g, '')}-tab`,

        });

        tab.add({
            xtype: 'container',
            layout: 'hbox',
            items: [panel]
        });

        panel.tab = tab;
    },

    _getModelName(panel) {
        let modelName = (panel.model && panel.model.elementName) || 'unknown';

        if (modelName === 'HierarchicalRequirement') {
            modelName = panel.model.displayName;
        }

        return modelName;
    },

    _applyFilters: function () {
        this.suspendEvents(false);
        this.suspendLayouts();
        _.each(this.filterControls, function (filterControl) {
            filterControl.inlineFilterButton._applyFilters();
        });
        this.resumeEvents();
        this.resumeLayouts(false);
        this.updateLayout();
    },

    _onFilterChange: function () {
        if (this.clearAllButton) {
            if (this._hasFilters()) {
                this.clearAllButton.show();
            }
            else {
                this.clearAllButton.hide();
            }
        }

        _.each(this.filterControls, function (filterControl) {
            let modelName = this._getModelName(filterControl.inlineFilterButton.inlineFilterPanel);
            this._setTabText(modelName, filterControl.inlineFilterButton.getFilters().length);
        }, this);

        if (this.ready) {
            this.fireEvent('change', this.getMultiLevelFilters());
        }
    },

    _setTabText: function (typeName, filterCount) {
        var titleText = filterCount ? `${typeName} (${filterCount})` : typeName;
        var tab = this.tabPanel.child(`#${typeName.replace(/\s+/g, '')}-tab`);

        if (tab) { tab.setTitle(titleText); }
    },

    _toggleFilters: function (btn) {
        if (this.tabPanel.isHidden()) {
            this.tabPanel.show();
            btn.setToolTipText('Hide Filters');
            btn.addCls('primary');
            btn.removeCls('secondary');
            btn.setFiltersHidden(false);
        } else {
            this.tabPanel.hide();
            btn.setToolTipText('Show Filters');
            btn.addCls('secondary');
            btn.removeCls('primary');
            btn.setFiltersHidden(true);
        }
    },

    _getAllTypePaths: function () {
        return _.map(this.allTypes, (type) => {
            return type.get('TypePath');
        });
    },

    /**
    *   Overrides to allow a store load to be canceled which will abort loading
    *   any subsequent pages and not invoke the load callback.
    */

    /*     TODO - Future work
 
     _addCancelLoad() {
 
         Ext.override(Rally.data.PageableStore, {
 
             loadCanceled: false,
 
             cancelLoad: function () {
                 this.loadCanceled = true;
             },
 
             load: function (options) {
                 this.loadCanceled = false;
                 this.callParent(arguments);
             },
 
             _shouldLoadMorePages: function (operation) {
                 if (this.loadCanceled) {
                     return false;
                 }
                 else {
                     return this.callParent(arguments)
                 }
             },
 
             _afterDoneLoadingAllPages: function (operation, success, callback, scope) {
                 if (this.loadCanceled) {
                     // Loading canceled. Don't send any events or invoke the callback
                     this.resumeEvents();
                     this.currentPage = 1;
                     this.loading = false;
                 }
                 else {
                     this.callParent(arguments);
                 }
             }
         });
     },
 
     */

    _showError(msg, defaultMessage) {
        Rally.ui.notify.Notifier.showError({ message: this.parseError(msg, defaultMessage) });
    },

    parseError(e, defaultMessage) {
        defaultMessage = defaultMessage || 'An unknown error has occurred';

        if (typeof e === 'string' && e.length) {
            return e;
        }
        if (e.message && e.message.length) {
            return e.message;
        }
        if (e.exception && e.error && e.error.errors && e.error.errors.length) {
            if (e.error.errors[0].length) {
                return e.error.errors[0];
            } else {
                if (e.error && e.error.response && e.error.response.status) {
                    return `${defaultMessage} (Status ${e.error.response.status})`;
                }
            }
        }
        if (e.exceptions && e.exceptions.length && e.exceptions[0].error) {
            return e.exceptions[0].error.statusText;
        }
        return defaultMessage;
    },

    onHelpClicked() {
        CustomAgile.ui.tutorial.MultiLevelFilterTutorial.showWelcomeDialog(this);
    }
});
/**
 *      Given a record and a field, return a user-friendly string representation
 */
Ext.define('CustomAgile.ui.renderer.RecordFieldRendererFactory', {
    singleton: true,

    colorPalette: {
        '#105cab': 'Dark Blue',
        '#21a2e0': 'Blue',
        '#107c1e': 'Green',
        '#4a1d7e': 'Purple',
        '#df1a7b': 'Pink',
        '#ee6c19': 'Burnt Orange',
        '#f9a814': 'Orange',
        '#fce205': 'Yellow',
        '#848689': 'Grey'
    },

    getFieldDisplayValue: function (record, field, delimiter, cleanseForExport) {
        if (!record || !field) {
            return '';
        }

        let val = record.get ? record.get(field) : record[field];
        let d = delimiter || ', ';

        if (_.isUndefined(val) || val === null) {
            val = '';
        }
        else if (typeof val === 'boolean') {
            val = val.toString();
        }
        else if (Ext.isDate(val)) {
            val = Rally.util.DateTime.formatWithDefaultDateTime(val);
        }
        else if (field === 'DisplayColor') {
            val = this.colorPalette[val] || val;
        }
        else if (field === 'Parent') {
            val = (val && (val.FormattedID && val.Name && val.FormattedID + ': ' + val.Name) || val._refObjectName) || (record.get('Feature') && ((record.get('Feature').FormattedID && record.get('Feature').Name && record.get('Feature').FormattedID + ': ' + record.get('Feature').Name) || record.get('Feature')._refObjectName)) || 'No Parent';
        }
        else if (field === 'Release') {
            val = (val && val.Name) || 'Unscheduled';
        }
        else if (field === 'Project') {
            val = (val && val.Name) || 'Failed to convert project field';
        }
        else if (field === 'Predecessors' || field === 'Successors') {
            val = typeof val === 'object' && typeof val.Count === 'number' ? val.Count : '';
        }
        else if (field === 'PredecessorsAndSuccessors') {
            val = typeof val.Predecessors === 'number' ? `Predecessors: ${val.Predecessors}; Successors: ${val.Successors}` : '';
        }
        else if (field === 'Owner' || field === 'CreatedBy') {
            val = val.DisplayName || (val.FirstName && val.LastName && `${val.FirstName} ${val.LastName}`) || val._refObjectName;

            if (!val && field === 'Owner') {
                val = 'No Owner';
            }
        }
        else if (field === 'PreliminaryEstimate') {
            val = `${val.Name} (${val.Value})`;
        }
        else if (field === 'Milestones') {
            if (val.Count) {
                val = _.map(val._tagsNameArray, (m) => {
                    return `${m.FormattedID}: ${m.Name}`;
                });
                val = val.join(d);
            }
            else {
                val = 'None';
            }
        }
        else if (field.toLowerCase().indexOf('portfolioitem/') > -1 || field === 'Feature') {
            val = val && `${val.FormattedID}: ${val.Name}` || 'None';
        }
        else if (typeof val === 'object') {
            if (val._tagsNameArray) {
                val = _.map(val._tagsNameArray, (m) => {
                    return m.Name || m.Value;
                });
                val = val.join(d);
            }
            else {
                val = val.Name || val.value || val._refObjectName || 'Unable to convert field for export';
            }
        }
        else if (_.isArray(val)) {
            val = val.join(d);
        }

        if (cleanseForExport) {
            val = this.cleanseExportValue(val.toString());
        }

        return val;
    },

    cleanseExportValue(val) {
        let reHTML = new RegExp('<\/?[^>]+>', 'gi');
        let reNbsp = new RegExp('&nbsp;', 'gi');

        if (reHTML.test(val)) {
            val = val.replace('<br>', '\r\n');
            val = Ext.util.Format.htmlDecode(val);
            val = Ext.util.Format.stripTags(val);
        }
        val = val.replace(reNbsp, ' ');

        return val;
    }
});
/*! moment-weekday-calc 1.1.4 andruhon <andrew@kondratev.pro> 2019-01-29 */
"undefined"!=typeof require&&(moment=require("moment")),function(u){function r(e,t,a,n,s,r){if(this.rangeStart=u(e),this.rangeEnd=u(t),this.exclusions=n,this.inclusions=s,this.useIsoWeekday=1==r,this.rangeStart.isAfter(this.rangeEnd))throw new f("rangeStart is after rangeEnd");this.weekdays=i(a,this.useIsoWeekday)}function f(e){this.message=e,this.name="WeekDayCalcException"}function d(e,t,a,n,s){this.rangeStart=u(e),this.useIsoWeekday=1==s,this.exclusions=a,this.inclusions=n,this.weekdays=i(t,this.useIsoWeekday)}function c(e){this.message=e,this.name="DaysSetConverterException"}r.prototype.calculate=function(){var e=0,t=this.rangeStart.clone().endOf("week"),a=this.rangeEnd.clone().startOf("week");a.diff(t,"days")<30||this.exclusions||this.inclusions?e=this.calculateIterative(this.rangeStart,this.rangeEnd,this.weekdays,this.exclusions,this.inclusions):(e+=Math.round(a.diff(t,"weeks",!0))*this.weekdays.length,e+=this.calculateIterative(this.rangeStart,t,this.weekdays),e+=this.calculateIterative(a,this.rangeEnd,this.weekdays));return e},r.prototype.calculateIterative=function(e,t,a,n,s){return this.iterateRange(e,t,a,n,s,null)},r.prototype.iterateRange=function(e,t,a,n,s,r){for(var i=0,o=e.clone(),d=l(n),c=l(s);o.valueOf()<=t.valueOf();){var u=this.useIsoWeekday?"isoWeekday":"weekday",f=o.format("YYYY-MM-DD");(0!=c.length&&0<=c.indexOf(f)||0<=a.indexOf(o[u]())&&(0==d.length||d.indexOf(f)<0))&&(r&&"function"==typeof r&&r(o.clone()),i++),o.add(1,"day")}return i},Function.prototype.construct=function(e){var t=this,a=function(){t.apply(this,e)};return a.prototype=t.prototype,new a},f.prototype=new Error,r.prototype.WeekDayCalcException=f,d.prototype.calculate=function(e){var t=e,a=this.rangeStart.clone(),n=l(this.exclusions),s=l(this.inclusions),r=this.useIsoWeekday?"isoWeekday":"weekday";if(0<=t)for(;0<t;){a.add(1,"day"),(0!=s.length&&0<=s.indexOf(a.format("YYYY-MM-DD"))||0<=this.weekdays.indexOf(a[r]())&&(0==n.length||n.indexOf(a.format("YYYY-MM-DD"))<0))&&t--}else for(;t<0;){a.subtract(1,"day"),(0!=s.length&&0<=s.indexOf(a.format("YYYY-MM-DD"))||0<=this.weekdays.indexOf(a[r]())&&(0==n.length||n.indexOf(a.format("YYYY-MM-DD"))<0))&&t++}return a},c.prototype=new Error,d.prototype.DaysSetConverterException=c;var i=function(e,t){var a=[];if(!e)throw new f("weekdays must be defined");if(7<e.length)throw new f("Weekdays array exceeding week length of 7 days");for(var n=0;n<e.length;n++){var s=e[n];if(t){if(isNaN(s))throw new f("isoWeekDayCalc accepts weekdays as numbers only, try using weekdayCalc if you need a locale aware behaviour");if(s<1||7<s)throw new f("The weekday is out of 1 to 7 range")}else if(isNaN(s))s=u().day(s).weekday();else if(s<0||6<s)throw new f("The weekday is out of 0 to 6 range");if(0<=a.indexOf(s))throw new f("Weekdays set contains duplicate weekday");a.push(s)}return a},l=function(e){var t=[];if(e)for(var a=0,n=e.length;a<n;a++)t.push(u(e[a]).format("YYYY-MM-DD"));return t};r.parseParameters=function(e,t,a){var n,s,r,i,o;switch(a=!!a,t.length){case 5:i=t[3],o=t[4];case 4:i=t[3];case 3:n=u(t[0]).startOf("day"),s=u(t[1]).endOf("day"),r=t[2];break;case 2:n=e,s=t[0],r=t[1];break;case 1:var d=t[0];d&&d.rangeEnd&&d.weekdays?(n=d.rangeStart?u(d.rangeStart).startOf("day"):e,s=u(d.rangeEnd).endOf("day"),r=d.weekdays,i=d.exclusions,o=d.inclusions):(n=e.clone().startOf("year"),s=e.clone().endOf("year"),r=d);break;default:new f("unexpected arguments length "+t.length+". Expecting 1 to 4 args")}if(n.isAfter(s)){var c=n.clone();n=s.clone(),s=c}return[n,s,r,i,o,a]},r.calculateWeekdays=function(e,t,a){return r.construct(r.parseParameters(e,t,a)).calculate()},r.dateRangeToDates=function(e,t,a){var n=[],s=r.construct(r.parseParameters(e,t,a));return s.iterateRange(s.rangeStart,s.rangeEnd,s.weekdays,s.exclusions,s.inclusions,function(e){n.push(e)}),n},d.calculateDate=function(e,t,a){var n,s,r,i;a=!!a;switch(t.length){case 4:s=t[2],r=t[3];case 3:s=t[2];case 2:n=t[0],i=t[1];break;case 1:var o=t[0];if(!o||null==o.days&&null==o.workdays)n=o;else{if(null!=o.days&&null!=o.workdays)throw new c("days and weekdays args should not be used together, because weekdays is an alias of days");n=o.days?o.days:o.workdays,i=o.weekdays?o.weekdays:[1,2,3,4,5],s=o.exclusions,r=o.inclusions}break;default:new c("unexpected arguments length "+t.length+". Expecting 1 to 3 args")}return d.construct([e,i,s,r,a]).calculate(n)},u.fn.weekdayCalc=function(){return r.calculateWeekdays(this,arguments)},u.fn.isoWeekdayCalc=function(){return r.calculateWeekdays(this,arguments,!0)},u.fn.addWorkdays=function(e,t,a){return d.calculateDate(this,[e,[1,2,3,4,5],t,a])},u.fn.workdaysToCalendarDays=function(e,t,a){return d.calculateDate(this,[e,[1,2,3,4,5],t,a]).diff(this,"days")},u.fn.addWeekdaysFromSet=function(){return d.calculateDate(this,arguments)},u.fn.weekdaysFromSetToCalendarDays=function(){return d.calculateDate(this,arguments).diff(this,"days")},u.fn.isoAddWeekdaysFromSet=function(){return d.calculateDate(this,arguments,!0)},u.fn.isoWeekdaysFromSetToCalendarDays=function(){return d.calculateDate(this,arguments,!0).diff(this,"days")},u.fn.dateRangeToDates=function(){return r.dateRangeToDates(this,arguments)},u.fn.dateRangeToDatesIso=function(){return r.dateRangeToDates(this,arguments,!0)},"object"==typeof exports&&"undefined"!=typeof module?module.exports=r:"function"==typeof define&&define.amd?define(r):this.WeekDayCalc=r}(moment);
//# sourceMappingURL=moment-weekday-calc.min.js.map
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink', {
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',

    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,

    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",

    defaults: { padding: 5, margin: 5 },

    closable: true,

    draggable: true,

    autoShow: true,

    width: 350,

    initComponent: function () {
        var id = Ext.id(this);
        this.title = "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },

    _generateChecksum: function (string) {
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/, "");
        string = string.replace(/\s/g, "");  //Remove all whitespace from the string.

        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }

        return chk;
    },

    _checkChecksum: function (container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;

        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if (CHECKSUM) {
                    if (CHECKSUM !== me._generateChecksum(text)) {
                        console.log("Checksums don't match!");
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });

        return deferred.promise;
    },

    afterRender: function () {
        var app = Rally.getApp();

        if (!app.isExternal()) {

            this._checkChecksum(app).then({
                scope: this,
                success: function (result) {
                    if (!result) {
                        this.addDocked({
                            xtype: 'container',
                            cls: 'build-info',
                            padding: 2,
                            html: '<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function (msg) {
                    console.log("oops:", msg);
                }
            });
        } else {
            this.addDocked({
                xtype: 'container',
                cls: 'build-info',
                padding: 2,
                html: '... Running externally'
            });
        }
        this.callParent(arguments);
    },

    beforeRender: function () {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml
            });
        }

        this.addDocked({
            xtype: 'container',
            cls: 'build-info',
            padding: 2,
            html: "This app was created by Custom Agile."
        });

        if (APP_BUILD_DATE) {
            this.addDocked({
                xtype: 'container',
                cls: 'build-info',
                padding: 2,
                html: 'Build date/time: ' + APP_BUILD_DATE
            });
        }
    }
});

Ext.define('CustomAgile.ui.picker.MultiSelectTimebox', {
    extend: 'Rally.ui.picker.MultiObjectPicker',
    alias: 'widget.customagilemultiselecttimebox',

    config: {
        remoteFilter: true,
        maxLength: 100,
        projects: null,
        pickerCfg: {
            cls: 'multiselect-timebox-picker',
            minWidth: 350
        },
        width: 150,
        enableGrouping: false,
        toggleOnClick: true,
        timeboxStartDateField: '',
        timeboxEndDateField: ''
    },

    initComponent() {
        Rally.ui.list.PagingToolbar.prototype.emptyMsg = 'No timeboxes';

        this.callParent(arguments);

        if (!this.store) {
            this.createStore();
        }
    },

    triggerBlur() {
        const { picker } = this;

        if (picker && picker.isVisible()) {
            this.collapse();
            this.callParent(arguments);
        }
    },

    getMatchedTextHtml(recordData) {
        return `<div class="timebox-name">${recordData.Name}</div>`;
    },

    resetFilters() {
        // TODO: do we need this for remote filter?
        // this.store.setFilter(this.getBaseFilter());
    },

    setValueBasedOnState(values = []) {
        const items = Ext.isString(values) ? values.split(',') : Ext.Array.from(values);

        if (!_.isEmpty(items) && this.store && this.store.isLoading()) {
            this.store.on('load', () => {
                this._selectValues(items);
            }, this, { single: true });
        } else {
            this._selectValues(items);
        }

        if (this.isExpanded) {
            this._onListRefresh();
            this._groupSelectedRecords();
        }

        this.fireEvent('stateapplied', this, this.selectedValues.getRange(), null);
    },

    setDefaultValue(items) {
        this._selectValues(items);

        this.fireEvent('defaultapplied', this, this.selectedValues.getRange(), null);
    },

    // eslint-disable-next-line consistent-return
    getTimeboxOidsInScope(selectedTimeboxes, callbackFn, scope) {
        if (selectedTimeboxes.length > 0) {
            let config = {
                model: Ext.identityFn(this.modelType),
                filters: this._getTimeboxFilters(selectedTimeboxes),
                fetch: ['Name', this.timeboxStartDateField, this.timeboxEndDateField, 'ObjectID'],
                autoLoad: true,
                listeners: {
                    load: (store, sharedTimeboxesInScope) => {
                        Ext.callback(callbackFn, scope, [sharedTimeboxesInScope]);
                    }
                }
            };
            if (this.projects) {
                config.filters = config.filters.and({ property: 'Project.ObjectID', operator: 'in', value: this.projects });
                config.context = {
                    project: null
                };
            }
            Ext.create('Rally.data.wsapi.Store', config);
        } else {
            Ext.callback(callbackFn, scope, [[]]);
        }
    },

    _getTimeboxFilters(records) {
        let filters = [];
        let foundSharedSchedule = {};

        _.each(records, (record) => {
            let key = `${record.get('Name')}-${record.get(this.timeboxStartDateField)}-${record.get(this.timeboxEndDateField)}`;
            if (!foundSharedSchedule[key]) {
                foundSharedSchedule[key] = true;
                let filterByTimebox = Rally.data.wsapi.Filter.and([
                    {
                        property: 'Name',
                        value: record.get('Name')
                    },
                    {
                        property: this.timeboxStartDateField,
                        value: record.get(this.timeboxStartDateField)
                    },
                    {
                        property: this.timeboxEndDateField,
                        value: record.get(this.timeboxEndDateField)
                    }
                ]);
                filters.push(filterByTimebox);
            }
        });
        return Rally.data.wsapi.Filter.or(filters);
    },

    /**
     * @override
     * Add support for specifying a store config option
     */
    createStore() {
        if (!this.store) {
            let storeBuilder = Ext.create('Rally.data.DataStoreBuilder');
            let storeConfig = Ext.merge({ model: this.modelType, requester: this }, this.storeConfig);

            return storeBuilder.build(storeConfig).then({
                success(store) {
                    this.store = store;
                    this.relayEvents(this.store, ['datachanged']);
                },
                scope: this
            });
        }
        return Promise.resolve(this.store);
    },

    /**
    * @override
    * Set buffer on keyup event for remote filtering to work
    * Add listener to inputtextchanged for local filtering
    */
    _initInputEvents() {
        if (!this.rendered) {
            this.on('afterrender', this._initInputEvents, this, { single: true });
            return;
        }

        this.on('expand', this.refreshView, this);
        // this.on('inputtextchanged', this._onInputTextChanged, this);
        this.mon(this.inputEl, 'keydown', this._onInputKeyDown, this, { buffer: 700 });
        this.mon(this.inputEl, 'keyup', this.validate, this, { buffer: 700 });
        this.mon(this.inputEl, 'keyup', this._onInputKeyUp, this, { buffer: 700 });
    },

    _onInputTextChanged() {
        this.store.clearFilter();
        this.store.filter({
            anyMatch: true, exactMatch: false, property: 'Name', value: this.getInputTextValue()
        });
        this.store.load();
    },

    /**
     * @override
     * Filter store if search field cleared
     */
    _onInputKeyUp(event) {
        this._setAppropriateEmptyText();

        // allow shift but disregard other modifiers
        if (event.shiftKey || !Rally.util.Event.isModifierKey(event)) {
            this._onInputTextChanged();
            // this.fireEvent('inputtextchanged', this.getInputTextValue());
        }
        if (this.getInputTextValue() === '') {
            if (this.store.filters) {
                this.store.filters.clear();
            }
            this.store.load();
        }
    },

    /**
    * @override
    * Wire up listeners for select and deselect instead of itemclick
    */
    _createList() {
        this.listCfg.pageSize = 10;
        let listCfg = Ext.apply({
            store: this.store,
            tpl: this._getListTpl(),
            createPagingToolbar: Ext.bind(this._createPagingToolbar, this)
        }, this.listCfg);

        this.list = Ext.create(this.listType, listCfg);

        this.mon(this.list, {
            refresh: this._onListRefresh,
            select: this.onListItemSelect,
            deselect: this.onListItemDeselect,
            scope: this
        });

        const pagingToolbar = this.getList().down('rallylistpagingtoolbar');
        pagingToolbar.onLoad();

        return this.list;
    },

    /**
     * @override
     * New signaure for onListItemSelect since wired up to select on the list
     */
    onListItemSelect(list, record) {
        this.select(record);
        this._selectRowCheckbox(record.get(this.recordKey));
        this._groupRecordsAndScroll(this._getRecordValue());
        this.refreshView();
        this.fireEvent('select', this, record, this.getValue());
        this._fireSelectionChange();
    },

    /**
     * @override
     * Find record in selectedValues mixedcollection and remove the record to be removed
     * New signaure for onListItemDeselect since wired up to deselect on the list
     */
    onListItemDeselect(list, record) {
        let foundRecord = null;

        const key = this._getKey(record);
        this.selectedValues.each((r) => {
            if (r.get('_ref') === key) {
                foundRecord = r;
            }
        });
        if (foundRecord) {
            this.selectedValues.remove(foundRecord);
        }
        this._syncSelection();
        this._deselectRowCheckbox(record.get(this.recordKey));
        this._groupRecordsAndScroll(this._getRecordValue());
        this.fireEvent('deselect', this, record, this.getValue());
        this._fireSelectionChange();
    },

    /**
    * @override
    * Fix for bug where sometimes the itemEl is not there
    */
    _deselectRowCheckbox(recordId) {
        if (this._getOptionCheckbox(recordId)) {
            this._getOptionCheckbox(recordId).removeCls('rui-picker-cb-checked');
        }
    },

    /**
    * @override
    */
    _onStoreLoaded() {
        this._syncSelection();

        this.callParent(arguments);
    },

    _createPagingToolbar() {
        return Ext.widget('rallylistpagingtoolbar', {
            store: this.store,
            border: false,
            layout: {
                align: 'middle'
            }
        });
    }
});
Ext.override(Rally.ui.combobox.FieldComboBox, {
    applyState: function (state) {
        if (this.store && !this.store.loading) {
            this.setValue(state.value);
            this.saveState();
        }
        else {
            this.callParent(arguments);
        }
    }
});

Ext.override(Rally.ui.DateField, {
    applyState: function (state) {
        if (state.value) {
            this.setValue(new Date(state.value));
        }
    }
});

Ext.override(Ext.form.field.Checkbox, {
    getState: function () {
        return { checked: this.getValue() };
    },
    applyState: function (state) {
        if (typeof state.checked === 'boolean') {
            this.setValue(state.checked);
        }
    }
});
Ext.define('recordHolder', {
    data: {},
    constructor: function (config) {
        Ext.apply(this, config);
    },

    get: function (field) {
        return this.data[field];
    }
});

Ext.define('Rally.technicalservices.FileUtilities', {
    singleton: true,

    saveCSVToFile: function (csv, file_name, type_object) {
        if (type_object === undefined) {
            type_object = { type: 'text/csv;charset=utf-8' };
        }
        this.saveAs(csv, file_name, type_object);
    },

    saveAs: function (textToWrite, fileName) {
        if (Ext.isIE9m) {
            Rally.ui.notify.Notifier.showWarning({ message: "Export is not supported for IE9 and below." });
            return;
        }

        var textFileAsBlob = null;
        try {
            textFileAsBlob = new Blob([textToWrite], { type: 'text/plain' });
        }
        catch (e) {
            window.BlobBuilder = window.BlobBuilder ||
                window.WebKitBlobBuilder ||
                window.MozBlobBuilder ||
                window.MSBlobBuilder;
            if (window.BlobBuilder) { //&&  e.name === 'TypeError'){
                bb = new BlobBuilder();
                bb.append([textToWrite]);
                textFileAsBlob = bb.getBlob("text/plain");
            }

        }

        if (!textFileAsBlob) {
            Rally.ui.notify.Notifier.showWarning({ message: "Export is not supported for this browser." });
            return;
        }

        var fileNameToSaveAs = fileName;

        if (Ext.isIE10p) {
            window.navigator.msSaveOrOpenBlob(textFileAsBlob, fileNameToSaveAs); // Now the user will have the option of clicking the Save button and the Open button.
            return;
        }

        var url = this.createObjectURL(textFileAsBlob);

        if (url) {
            var downloadLink = document.createElement("a");
            if ("download" in downloadLink) {
                downloadLink.download = fileNameToSaveAs;
            } else {
                //Open the file in a new tab
                downloadLink.target = "_blank";
            }

            downloadLink.innerHTML = "Download File";
            downloadLink.href = url;
            if (!Ext.isChrome) {
                // Firefox requires the link to be added to the DOM
                // before it can be clicked.
                downloadLink.onclick = this.destroyClickedElement;
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
            }
            downloadLink.click();
        } else {
            Rally.ui.notify.Notifier.showError({ message: "Export is not supported " });
        }

    },
    createObjectURL: function (file) {
        if (window.webkitURL) {
            return window.webkitURL.createObjectURL(file);
        } else if (window.URL && window.URL.createObjectURL) {
            return window.URL.createObjectURL(file);
        } else {
            return null;
        }
    },
    saveTextAsFile: function (textToWrite, fileName) {
        var textFileAsBlob = new Blob([textToWrite], { type: 'text/plain' });
        var fileNameToSaveAs = fileName;

        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.innerHTML = "Download File";
        if (window.webkitURL != null) {
            // Chrome allows the link to be clicked
            // without actually adding it to the DOM.
            downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
        }
        else {
            // Firefox requires the link to be added to the DOM
            // before it can be clicked.
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
            downloadLink.onclick = destroyClickedElement;
            downloadLink.style.display = "none";
            document.body.appendChild(downloadLink);
        }
        downloadLink.click();
    },
    destroyClickedElement: function (event) {
        document.body.removeChild(event.target);
    },
    convertDataArrayToCSVText: function (data_array, requestedFieldHash) {

        var text = '';
        Ext.each(Object.keys(requestedFieldHash), function (key) {
            text += requestedFieldHash[key] + ',';
        });
        text = text.replace(/,$/, '\n');

        Ext.each(data_array, function (d) {
            Ext.each(Object.keys(requestedFieldHash), function (key) {
                if (d[key]) {
                    if (typeof d[key] === 'object') {
                        if (d[key].FormattedID) {
                            text += Ext.String.format("\"{0}\",", d[key].FormattedID);
                        } else if (d[key].Name) {
                            text += Ext.String.format("\"{0}\",", d[key].Name);
                        } else if (!isNaN(Date.parse(d[key]))) {
                            text += Ext.String.format("\"{0}\",", Rally.util.DateTime.formatWithDefaultDateTime(d[key]));
                        } else {
                            text += Ext.String.format("\"{0}\",", d[key].toString());
                        }
                    } else {
                        text += Ext.String.format("\"{0}\",", d[key]);
                    }
                } else {
                    text += ',';
                }
            }, this);
            text = text.replace(/,$/, '\n');
        }, this);
        return text;
    },
    _getCSVFromWsapiBackedGrid: function (grid, skip_headers) {
        var deferred = Ext.create('Deft.Deferred');
        var store = Ext.create('Rally.data.wsapi.Store', {
            fetch: grid.getStore().config.fetch,
            filters: grid.getStore().config.filters,
            model: grid.getStore().config.model,
            pageSize: 200
        });

        var columns = grid.columns;

        var record_count = grid.getStore().getTotalCount(),
            page_size = grid.getStore().pageSize,
            pages = Math.ceil(record_count / page_size),
            promises = [];

        for (var page = 1; page <= pages; page++) {
            promises.push(this.loadStorePage(grid, store, columns, page, pages));
        }
        Deft.Promise.all(promises).then({
            success: function (csvs) {
                var csv = [];
                if (!skip_headers) {
                    csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');
                }
                _.each(csvs, function (c) {
                    _.each(c, function (line) {
                        csv.push(line);
                    });
                });
                csv = csv.join('\r\n');
                deferred.resolve(csv);
                Rally.getApp().setLoading(false);
            }
        });
        return deferred.promise;
    },

    getCSVFromRows: function (scope, grid, rows) {
        var me = this;
        var store = grid.getStore();
        var csv = [];

        csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');
        Ext.Array.each(rows, function (row) {
            csv.push(me._getCSVFromRecord(Ext.create('recordHolder', { data: row }), grid, store));
        });

        csv = csv.join('\r\n');
        return csv;
    },

    // custom grid assumes there store is fully loaded
    _getCSVFromCustomBackedGrid: function (grid, skip_headers) {
        var deferred = Ext.create('Deft.Deferred');
        var store = Ext.clone(grid.getStore());
        var columns = grid.columns;
        Rally.getApp().setLoading("Generating CSV...");

        var record_count = store.getTotalCount(),
            page_size = store.pageSize,
            pages = Math.ceil(record_count / page_size),
            promises = [];

        for (var page = 1; page <= pages; page++) {
            promises.push(this.loadStorePage(grid, store, columns, page, pages));
        }

        Deft.Promise.all(promises).then({
            scope: this,
            success: function (csvs) {
                var csv = [];
                if (!skip_headers) {
                    csv.push('"' + this._getHeadersFromGrid(grid).join('","') + '"');
                }
                _.each(csvs, function (c) {
                    _.each(c, function (line) {
                        csv.push(line);
                    });
                });
                csv = csv.join('\r\n');
                deferred.resolve(csv);
                Rally.getApp().setLoading(false);
            }
        });
        return deferred.promise;
    },

    _getHeadersFromGrid: function (grid) {
        var headers = [];
        var columns = grid.columns;

        Ext.Array.each(columns, function (column) {
            if (column.hidden) { return; }

            if (column.dataIndex || column.renderer) {
                if (column.csvText) {
                    headers.push(column.csvText.replace('&nbsp;', ' '));
                } else if (column.text) {
                    headers.push(column.text.replace('&nbsp;', ' '));
                }
            }
        });

        return headers;
    },

    _getColumnNamesFromGrid: function (grid) {
        var names = [];
        var columns = grid.columns;

        Ext.Array.each(columns, function (column) {
            if (column.dataIndex || column.renderer) {
                names.push(column.dataIndex);
            }
        });

        return names;
    },
    /*
     * will render using your grid renderer.  If you want it to ignore the grid renderer, 
     * have the column set _csvIgnoreRender: true
     */
    getCSVFromGrid: function (app, grid, skip_headers) {
        if (Ext.getClassName(grid.getStore()) != "Rally.data.custom.Store") {
            return this._getCSVFromWsapiBackedGrid(grid, skip_headers);
        }

        return this._getCSVFromCustomBackedGrid(grid, skip_headers);
    },
    loadStorePage: function (grid, store, columns, page, total_pages) {
        var deferred = Ext.create('Deft.Deferred');

        store.loadPage(page, {
            callback: function (records) {
                var csv = [];
                Rally.getApp().setLoading(Ext.String.format('Page {0} of {1} loaded', page, total_pages));
                for (var i = 0; i < records.length; i++) {
                    var record = records[i];
                    csv.push(this._getCSVFromRecord(record, grid, store));
                }
                deferred.resolve(csv);
            },
            scope: this
        });
        return deferred;
    },

    _getCSVFromRecord: function (record, grid, store) {
        var mock_meta_data = {
            align: "right",
            classes: [],
            cellIndex: 9,
            column: null,
            columnIndex: 9,
            innerCls: undefined,
            recordIndex: 5,
            rowIndex: 5,
            style: "",
            tdAttr: "",
            tdCls: "x-grid-cell x-grid-td x-grid-cell-headerId-gridcolumn-1029 x-grid-cell-last x-unselectable",
            unselectableAttr: "unselectable='on'"
        };

        var node_values = [];
        var columns = grid.columns;

        Ext.Array.each(columns, function (column) {
            if (column.xtype == 'rallyrowactioncolumn' || column.xtype == 'tsrowactioncolumn') {
                return;
            }

            if (column.hidden) {
                return;
            }

            if (column.dataIndex) {
                var column_name = column.dataIndex;

                var display_value = record.get(column_name);

                if (!column._csvIgnoreRender && (column.renderer || column.exportRenderer)) {
                    if (column.exportRenderer) {
                        display_value = column.exportRenderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                    } else {
                        display_value = column.renderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                    }
                }
                node_values.push(display_value);
            } else {
                var display_value = null;
                if (!column._csvIgnoreRender && column.renderer) {
                    if (column.exportRenderer) {
                        display_value = column.exportRenderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
                    } else {
                        display_value = column.renderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
                    }
                    node_values.push(display_value);
                }
            }
        }, this);

        var csv_string = "";
        Ext.Array.each(node_values, function (node_value, idx) {
            if (idx > 0) {
                csv_string = csv_string + ",";
            }
            if (/^=/.test(node_value)) {
                csv_string = csv_string + node_value;
            } else {
                csv_string = csv_string + '"' + node_value + '"';
            }

        });

        return csv_string;
    }

});
Ext.define('CustomAgile.ui.picker.MultiSelectProject', {
    extend: 'CustomAgile.ui.picker.MultiSelectTimebox',
    alias: 'widget.customagilemultiselectproject',
    requires: [
        'CustomAgile.ui.picker.MultiSelectTimebox'
    ],

    config: {
        modelType: 'Project',
        emptyText: 'Search projects...',
        storeConfig: {
            autoLoad: true,
            limit: 10,
            pageSize: 10,
            remoteSort: true,
            remoteFilter: true,
            fetch: ['ObjectID', 'Name'],
            sorters: [{ property: 'Name', direction: 'ASC' }],
            context: { project: null }
        }
    },

    /**
     * @override
     * override no data message
     */
    initComponent() {
        this.callParent(arguments);

        Rally.ui.list.PagingToolbar.prototype.emptyMsg = `No ${this.modelType}s`;
    },

    getFilter() {
        let projects = this.getValue();

        return {
            property: 'Project',
            operator: 'in',
            value: _.map(projects, p => p.get('_ref'))
        };
    },

    getLookbackFilter() {
        let projects = this.getValue();

        return {
            property: 'Project',
            operator: 'in',
            value: _.map(projects, p => p.get('ObjectID'))
        };
    }
});

Ext.define('Customagile.ui.PillPicker', {
    extend: 'Ext.Container',
    alias: 'widget.customagilepillpicker',

    /**
     * @cfg {Object} config for the MultiObjectPicker
     */
    pickerCfg: null,

    /**
     * @cfg {Boolean} true to show pills
     */
    showPills: true,

    /**
    * @cfg {String} Unique string to persist selected items
    */
    statefulKey: null,

    /**
     * @cfg {Boolean} true if omitting same timebox name/dates
     */
    sharedSchedules: false,

    /**
   * @cfg {Boolean} true to set picker to most recent 5 timeboxes if no selections restored from state
   */
    defaultToRecentTimeboxes: true,

    initComponent() {
        let selectedItems = [];
        this.recordsToAdd = [];

        this.picker = Ext.ComponentManager.create(this.pickerCfg);
        this.mon(this.picker, 'selectionchange', this._onSelectionChange, this);
        this.mon(this.picker, 'select', this._onItemSelect, this);
        this.mon(this.picker, 'deselect', this._onItemDeselect, this);
        this.mon(this.picker, 'expand', this._onInitialExpand, this, { single: true });

        this.items = this._createItems();

        if (this.statefulKey) {
            selectedItems = JSON.parse(localStorage.getItem(this.statefulKey));
        }

        if (selectedItems && selectedItems.length > 0) {
            Ext.create('Rally.data.wsapi.RefsToRecords').convert(selectedItems, { requester: this }).then({
                success: (timeboxes) => {
                    if (this.sharedSchedules) {
                        this.picker.getTimeboxOidsInScope(timeboxes, (recordsToAdd) => {
                            this.recordsToAdd = recordsToAdd;
                            if (recordsToAdd && recordsToAdd.length > 0) {
                                this.picker.setValueBasedOnState(recordsToAdd);
                                this._addPills(recordsToAdd);
                                this.saveStateLocal(recordsToAdd);
                            } else {
                                this._setDefaults();
                            }
                        }, this);
                    } else {
                        this.recordsToAdd = timeboxes;
                        this.picker.setValueBasedOnState(timeboxes);
                        this._addPills(timeboxes);
                        this.saveStateLocal(timeboxes);
                    }
                },
                scope: this
            });
        } else {
            if (this.sharedSchedules) {
                const records = this.picker.store.getRange(0, 9);
                if (this.defaultToRecentTimeboxes) {
                    this.recordsToAdd = records;
                    this.picker.setDefaultValue(records);
                } else {
                    this.recordsToAdd = [];
                    this.picker.setValueBasedOnState([]);
                }
            } else {
                this.picker.createStore().then({
                    success: () => {
                        this.mon(this.picker, 'datachanged', this._onInitialDataChanged, this, { single: true });
                    },
                    scope: this
                });
            }
        }

        this.callParent(arguments);
        if (this.sharedSchedules) {
            this._addPills(this.recordsToAdd);
        }
    },

    getValue() {
        const { picker } = this;
        if (picker) {
            return picker.getValue();
        }

        return [];
    },

    getFilter() {
        return this.picker && this.picker.getFilter();
    },

    getLookbackFilter() {
        return this.picker && this.picker.getLookbackFilter();
    },

    saveStateLocal(records) {
        if (this.statefulKey) {
            try {
                localStorage.setItem(this.statefulKey, JSON.stringify(_.invoke(records, 'get', '_ref')));
            } catch (e) {
                // noop
            }
        }
    },

    _onInitialDataChanged() {
        this._setDefaults();
    },

    _setDefaults() {
        if (this.recordsToAdd.length === 0) {
            if (this.defaultToRecentTimeboxes) {
                Ext.create('Rally.data.wsapi.Store', {
                    model: 'Release',
                    autoLoad: true,
                    limit: 4,
                    pageSize: 4,
                    remoteSort: true,
                    remoteFilter: true,
                    fetch: ['ObjectID', 'Name', 'ReleaseStartDate', 'ReleaseDate'],
                    sorters: [{ property: 'ReleaseDate', direction: 'DESC' }],
                    filters: [{ property: 'ReleaseStartDate', operator: '<', value: new Date() }],
                    context: {
                        project: Rally.getApp().getContext().getProjectRef(),
                        projectScopeUp: false,
                        projectScopeDown: false
                    },
                    listeners: {
                        scope: this,
                        load: function (store, data, success) {
                            if (success) {
                                this.picker.setDefaultValue(data);
                                this._addPills(data);
                            }
                            else {
                                this.picker.setDefaultValue([]);
                            }
                        }
                    }
                });
            } else {
                this.picker.setValueBasedOnState([]);
            }
        }
    },

    _onInitialExpand() {
        if (this.picker.getList()) {
            this.picker.getList().pagingToolbar.onLoad();
            this.picker.getList().refresh();
        }
    },

    _addPills(records) {
        let recordsForPills = records;
        if (!this.showPills) {
            return;
        }
        if (this.sharedSchedules) {
            let foundRecords = {};
            recordsForPills = _.filter(records, (record) => {
                let key = `${record.get('Name')}-${record.get(this.startDateFieldName)}-${record.get(this.endDateFieldName)}`;
                if (!foundRecords[key]) {
                    foundRecords[key] = true;
                    return true;
                }
                return false;
            });
        }

        const pills = _.map(recordsForPills, record => ({
            xtype: 'component',
            flex: 1,
            itemId: `pill-id-${record.getId()}`,
            renderTpl: '<span class="tagPill">{Name}<span class="icon-cancel"></span></span>',
            renderData: record.getData(),
            renderSelectors: {
                tagPill: '.tagPill',
                removePillEl: '.icon-cancel'
            },
            listeners: {
                click: {
                    element: 'tagPill',
                    fn: (e) => {
                        e.preventDefault();
                        this._onRemovePillClick(record);
                    },
                    scope: this
                }
            }
        }), this);
        const newPills = _.filter(pills, cmp => _.isEmpty(this.down(`#${cmp.itemId}`)), this);

        if (newPills.length > 0) {
            this.down('#pillContainer').add(newPills);
        }
    },

    _createItems() {
        return [
            this.picker,
            {
                itemId: 'pillContainer',
                xtype: 'container',
                cls: 'pill-select-container',
                margin: '10 0 0 0',
                layout: {
                    type: 'table',
                    columns: 3
                }
            }
        ];
    },

    _removePills() {
        _.each(this.down('#pillContainer').items.getRange(), (cmp) => {
            cmp.destroy();
        });
    },

    _removePill(record) {
        let pillEl = this.down(`#pill-id-${record.getId()}`);
        if (pillEl) {
            pillEl.destroy();
        }
    },

    _onSelectionChange(cmp, records) {
        Ext.suspendLayouts();
        this._removePills();
        this._addPills(records);
        Ext.resumeLayouts(true);
        this.saveStateLocal(records);
    },

    _onItemSelect(cmp, record) {
        this._addPills(Ext.Array.from(record));
    },

    _onItemDeselect(cmp, record) {
        this._removePill(record);
    },

    _findSharedSchedules(record) {
        const selectedValues = this.picker.selectedValues.getRange();
        const key = `${record.get('Name')}-${record.get(this.startDateFieldName)}-${record.get(this.endDateFieldName)}`;
        return _.filter(selectedValues, (timebox) => {
            const timeboxKey = `${timebox.get('Name')}-${timebox.get(this.startDateFieldName)}-${timebox.get(this.endDateFieldName)}`;
            return timeboxKey === key;
        });
    },

    _onRemovePillClick(record) {
        if (this.sharedSchedules) {
            const recordsToRemove = this._findSharedSchedules(record);
            _.each(recordsToRemove, (r) => {
                this.picker.onListItemDeselect(null, r);
                this._removePill(r);
            });
        } else {
            this.picker.onListItemDeselect(null, record);
            this._removePill(record);
        }

        this.saveStateLocal(this.picker.selectedValues.getRange());
        this.fireEvent('recordremoved', this.picker.selectedValues, record, this.picker);
    }
});
Ext.define('Customagile.ui.ProjectPicker', {
    extend: 'Ext.Container',
    alias: 'widget.customagileprojectpicker',
    layout: 'vbox',

    cmp: null,
    appName: '',
    tab: null,

    initComponent() {
        this.callParent(arguments);

        this.add([
            {
                xtype: 'component',
                html: `If you require a report spanning across multiple project hierarchies, use this project picker to specify where the data will be pulled from. If blank, app will respect user's current project scoping.`,
                cls: 'x-form-item-label'
            },
            {
                xtype: 'customagilepillpicker',
                itemId: 'projectPicker',
                hidden: false,
                statefulKey: this.cmp.getContext().getScopedStateId(this.appName + '-project-picker'),
                defaultToRecentTimeboxes: false,
                listeners: {
                    recordremoved: this.projectsChanged,
                    scope: this
                },
                pickerCfg: {
                    xtype: 'customagilemultiselectproject',
                    width: 350,
                    margin: '10 0 0 0',
                    listeners: {
                        blur: this.projectsChanged,
                        change: this.projectsChanged,
                        scope: this
                    }
                }
            },
            {
                xtype: 'rallycheckboxfield',
                itemId: 'includeChildProjectsCheckbox',
                fieldLabel: 'Show work from child projects',
                labelSeparator: '',
                stateful: true,
                stateId: this.cmp.getContext().getScopedStateId(this.appName + '-scope-down-checkbox'),
                stateEvents: ['change'],
                labelWidth: 200,
                listeners: {
                    scope: this,
                    change: this.projectsChanged
                }
            }
        ]);

        this.projectPicker = this.down('#projectPicker');
        setTimeout(this.updateProjectTabText, 1000);
    },

    projectsChanged() {
        this.updateProjectTabText();
        this.fireEvent('projectschanged');
    },

    updateProjectTabText() {
        if (this.tab && this.projectPicker) {
            let totalProjects = this.projectPicker.getValue().length;
            let titleText = totalProjects ? `PROJECTS (${totalProjects})` : 'PROJECTS';
            this.tab.setTitle(titleText);
        }
    },

    getValue() {
        return this.projectPicker.getValue();
    },

    includeChildProjects() {
        return this.down('#includeChildProjectsCheckbox').getValue();
    }
});
Ext.define('CustomAgile.ui.tutorial.TimeInStateTutorial', {
    singleton: true,

    welcomeHtml: `
    <p>This app displays a grid of work items and the time each item spent in each "state".</p>
    <p>Additional fields can be added to the grid as columns and the data can be exported to a CSV file.</p>
    <p><b>Data caveats:</b></p>
    <ul>
        <li>Only changes to state or blockers between the start date and end date (today's date if end date is blank) 
            are retrieved. Any changes before this period will not be reflected in the report and may cause certain time 
            in state values to be off from expectations.</li>
        <li>If an artifact is moved in and out of the selected project scoping, those changes to the state or blockers 
            while outside of the scope will not be captured in the report.</li>
    </ul>
    `,

    defaultOffset: [
        { x: 0, y: 0 },
        { x: 0, y: 0 },
        { x: 0, y: 0 },
        { x: 0, y: 0 }
    ],

    defaultChevronOffset: [
        { x: 0, y: -14 },
        { x: 14, y: 0 },
        { x: 0, y: 14 },
        { x: -8, y: 0 }
    ],

    steps: [
        {
            target: 'tabbar tab',
            title: 'Filters and Settings',
            placement: 'bottom',
            offset: [
                { x: 0, y: 0 },
                { x: 0, y: 0 },
                { x: 0, y: 14 },
                { x: 0, y: 0 }
            ],
            html: `
            <p>This series of tabs allows complete control over what data is aggregated and how it is displayed in the grid.</p>
            `,
            handler: () => {
                if (Rally.getApp().down('#filterAndSettingsPanel').getCollapsed()) {
                    Rally.getApp().collapseBtn.handler(Rally.getApp().collapseBtn);
                }
                Rally.getApp().down('#filterAndSettingsPanel').setActiveTab(0);
                Rally.getApp().ancestorFilterPlugin.showHelpButton();
            }
        },
        {
            target: '#' + Utils.AncestorPiAppFilter.PANEL_RENDER_AREA_ID,
            placement: 'bottom',
            title: 'Filters',
            html: `
            <p>This section provides fine-tuning of which work items display in the grid.</p>
            <p>Filters can be applied to stories and portfolio items. Scope can be set to the current project(s) or across the entire workspace via the "Owned by" dropdown
            (workspace scoping will result in longer load times or even timeouts). If any projects are selected via the project picker on the projects tab, it will override this scope selector.</p>
            <p>Additional filter help can be found by clicking on the help button in the top-right corner of the filters section.</p>
            `,
            handler: () => {
                Rally.getApp().down('#filterAndSettingsPanel').setActiveTab(0);
                Rally.getApp().ancestorFilterPlugin.showHelpButton();
            }
        },
        {
            target: '#settingsTab',
            placement: 'bottom',
            title: 'Report Settings',
            offset: [
                { x: 0, y: 0 },
                { x: 0, y: 0 },
                { x: 0, y: 14 },
                { x: 0, y: 0 }
            ],
            html: `
            <p>This section provides options for controlling the work item type, state values and timeframe for the report.</p>
            <p><b>Type: </b>The work item type to show in the grid</p>
            <p><b>State Field: </b>Once a type is selected, the state field dropdown populates with possible fields that could be used to show the work items' transitions across states and the duration in each state.</p>
            <p><b>Start State / End State: </b>The range of states to include in the report. Any states before the start state and after the end state will not show in the report. If an item enters and 
            leaves the same state multiple times, the time in state is the sum of all time in that state.</p>
            <p><b>Include Blocked Time For Each State: </b>Selecting this checkbox will add a column for every state which provides the duration in which each artifact was blocked while in that state. The duration is 
            in the same time format as the time in state metric.</p>
            <p><b>Start Date / End Date: </b>The next 2 inputs specify the date range for the report. A start date is required. If an end date is not specified, the app defaults 
            to today. The app will only show items that have experienced at least one state transition within the specified date range.</p>
            <p><b>Columns: </b>For a cleaner looking grid (especially one that includes many states), selecting "Time In State" will only show a single column for each state, specifying the amount of time each work item was in 
            each state. Selecting "Time In State And Enter/Exit Dates" will also include columns specifying the dates at which the work items first entered and last exited each state.</p>
            <p><b>Format: </b>The time in state can be formatted as number of days or number of weeks spent in each state.</p>
            <p><b>Exclude Weekends: </b>If format is set to Days, an option is available to exclude weekends (Saturdays and Sundays) from the time in state calculations.</p>
            `,
            handler: () => {
                Rally.getApp().down('#filterAndSettingsPanel').setActiveTab(1);
                Rally.getApp().ancestorFilterPlugin.hideHelpButton();
            }
        },
        {
            target: '#projectsTab',
            placement: 'bottom',
            title: 'Projects',
            offset: [
                { x: 0, y: 0 },
                { x: 0, y: 0 },
                { x: 0, y: 14 },
                { x: 0, y: 0 }
            ],
            html: `
            <p>This section is useful for fine-tuning the scope of projects that are included when loading user story data. If any projects are selected from this dropdown, they will be used instead of your current project scoping. This will also override the "Owned by any project" dropdown on the Filters tab.</p>
            <p>To include all projects below the selected projects, select the checkbox labeled "Show work from child projects".</p>
            `,
            handler: () => Rally.getApp().down('#filterAndSettingsPanel').setActiveTab(2)
        },
        {
            target: '#updateBtn',
            placement: 'bottom',
            title: 'Button Bar',
            chevronOffset: [
                { x: 0, y: 0 },
                { x: 0, y: 0 },
                { x: 140, y: 14 },
                { x: 0, y: 0 }
            ],
            offset: [
                { x: 0, y: 0 },
                { x: 0, y: 0 },
                { x: 0, y: 14 },
                { x: 0, y: 0 }
            ],
            html: `
            <p><b>Column Chooser: </b>Use this field picker to select additional columns to appear in the report. The additional columns will also be included in the export file.</p>
            <p><b>Update: </b>Once all of the necessary filters and settings have been selected, click this button to generate the report.</p>
            <p><b>Export: </b>Once the report has been generated, this button will create a CSV file including all of the data contained within the report.</p>
            `
        }
    ],

    showWelcomeDialog: function (app) {
        this.app = app;

        if (app.down('#filterAndSettingsPanel').getCollapsed()) {
            app.collapseBtn.handler(app.collapseBtn);
        }
        app.down('#filterAndSettingsPanel').setActiveTab(0);
        app.ancestorFilterPlugin.showHelpButton();

        this.welcomeDialog = Ext.create('Rally.ui.dialog.Dialog', {
            autoShow: true,
            layout: 'fit',
            componentCls: 'rly-popover dark-container',
            width: 500,
            height: 400,
            closable: true,
            autoDestroy: true,
            buttonAlign: 'center',
            autoScroll: true,
            title: 'Using the Time In State App',
            items: {
                xtype: 'component',
                html: this.welcomeHtml,
                padding: 10,
                style: 'font-size:12px;'
            },
            buttons: [
                {
                    xtype: "rallybutton",
                    text: 'Close',
                    cls: 'secondary rly-small',
                    listeners: {
                        click: () => {
                            this.welcomeDialog.close();
                        },
                        scope: this
                    }
                }, {
                    xtype: "rallybutton",
                    text: 'Next',
                    cls: 'primary rly-small',
                    listeners: {
                        click: function () {
                            this.showNextStep(0);
                            this.welcomeDialog.close();
                        },
                        scope: this
                    }
                }
            ]
        });
    },

    showNextStep: function (stepIndex) {
        if (this.popover) {
            Ext.destroy(this.popover);
        }

        if (stepIndex >= this.steps.length) {
            return;
        }

        if (stepIndex === -1) {
            this.showWelcomeDialog(this.app);
            return;
        }

        let currentStep = this.steps[stepIndex];

        if (currentStep.handler) {
            currentStep.handler();
        }

        let buttons = [{
            xtype: "rallybutton",
            text: 'Close',
            cls: 'secondary rly-small',
            listeners: {
                click: () => {
                    this.popover.close();
                },
                scope: this
            }
        }];

        buttons.push({
            xtype: "rallybutton",
            text: 'Previous',
            cls: 'primary rly-small',
            listeners: {
                click: function () {
                    this.showNextStep(stepIndex - 1);
                },
                scope: this
            }
        });

        if (stepIndex < this.steps.length - 1) {
            buttons.push({
                xtype: "rallybutton",
                text: 'Next',
                cls: 'primary rly-small',
                listeners: {
                    click: function () {
                        this.showNextStep(stepIndex + 1);
                    },
                    scope: this
                }
            });
        }

        this.popover = Ext.create('Rally.ui.popover.Popover', {
            target: this.app.down(currentStep.target).getEl(),
            placement: currentStep.placement || ['bottom', 'left', 'top', 'right'],
            chevronOffset: currentStep.chevronOffset || this.defaultChevronOffset,
            offsetFromTarget: currentStep.offset || this.defaultOffset,
            overflowY: 'auto',
            maxWidth: 700,
            maxHeight: 700,
            toFront: Ext.emptyFn,
            buttonAlign: 'center',
            title: currentStep.title,
            listeners: {
                destroy: function () {
                    this.popover = null;
                },
                scope: this
            },
            html: `<div class="tutorial-popover-body">${currentStep.html}</div>`,
            buttons
        });
    }

});
Ext.define('Rally.ui.combobox.CustomPortfolioItemTypeComboBox', {

    extend: 'Rally.ui.combobox.ComboBox',
    alias: 'widget.tsrecordtypecombobox',

    preferenceName: 'tsTypeCombo',

    config: {

        typeFilter: [
            {
                property: 'Parent.Name',
                operator: '=',
                value: 'Portfolio Item'
            },
            {
                property: 'Creatable',
                operator: '=',
                value: 'true'
            }
        ],

        typeSorter: [{
            property: 'Ordinal',
            direction: 'Desc'
        }],

        valueField: 'TypePath',
        displayField: 'Name'
    },

    constructor: function (config) {
        if (Ext.isEmpty(config.typeFilter) || config.typeFilter == [] || config.typeFilter == {}) {
            config.typeFilter = [{ property: 'ObjectID', operator: '>', value: 0 }];
        }
        if (Ext.isObject(config.typeFilter)) {
            config.typeFilter = [config.typeFilter];
        }

        var defaultConfig = {
            defaultSelectionPosition: 'last',
            editable: false,
            fieldLabel: 'Type:',
            labelWidth: 30,
            context: Rally.environment.getContext(),
            storeConfig: {
                autoLoad: false,
                remoteFilter: true,
                model: Ext.identityFn('TypeDefinition'),
                sorters: config.typeSorter,
                filters: config.typeFilter,
                listeners: {
                    load: function (store, records) {
                        // console.log('types:', records);
                    }
                }
            }
        };

        if (config.storeConfig) {
            delete config.storeConfig.autoLoad;

            if (config.storeConfig.additionalFilters) {
                defaultConfig.storeConfig.filters = defaultConfig.storeConfig.filters.concat(config.storeConfig.additionalFilters);
            }
        }

        this.callParent([Ext.Object.merge(defaultConfig, config)]);
    },

    initComponent: function () {
        this.callParent();

        Deft.Promise.all([this.getPreference(), this._loadStore()]).then({
            success: function (results) {
                var pref = results[0];
                if (pref && this._isPrefValueInStore(pref)) {
                    this.setValue(pref);
                }
                this.on('change', this._onValueChange, this);
                this.onReady({ preferencesLoaded: true, record: this.getRecord() });
            },
            scope: this
        });
    },

    onReady: function (options) {
        options = options || {};

        // Only call the base onReady (which fires the 'ready' event, when both the store and preferences have loaded
        if (options.preferencesLoaded) {
            this.fireEvent('select', options.record);
            this.callParent(arguments);
        }
    },

    getSelectedType: function () {
        return this.getTypeFromRef(this.getValue());
    },

    getTypeFromRef: function (typeRef) {
        return this.getStore().findRecord('_ref', typeRef);
    },

    getTypeWithOrdinal: function (ordinal) {
        return this.getStore().findRecord("Ordinal", ordinal);
    },

    getAllTypeNames: function () {
        return _.map(this.getStore().getRecords(), function (type) { return type.get('TypePath'); });
    },

    _onValueChange: function (field, newValue) {
        this.savePreference(newValue);
    },

    _loadStore: function () {
        var deferred = new Deft.Deferred();

        this.store.load({
            callback: function (records, operation, success) {
                if (success) {
                    deferred.resolve();
                } else {
                    deferred.reject();
                }
            },
            scope: this
        });

        return deferred.promise;
    },

    getPreference: function () {
        var deferred = new Deft.Deferred();

        Rally.data.PreferenceManager.load(Ext.apply(this._getPreferenceConfig(), {
            success: function (prefs) {
                deferred.resolve(prefs[this._getPreferenceName()]);
            },
            scope: this
        }));

        return deferred.promise;
    },

    savePreference: function (value) {
        var settings = {};
        settings[this._getPreferenceName()] = value;

        Rally.data.PreferenceManager.update(Ext.apply(this._getPreferenceConfig(), {
            settings: settings
        }));
    },

    _getPreferenceConfig: function () {
        var config = {
            filterByUser: true,
            filterByName: this._getPreferenceName()
        };

        if (this.context.get && this.context.get('appID')) {
            config.appID = this.context.get('appID');
        }

        return config;
    },

    _getPreferenceName: function () {
        return this.preferenceName + '-' + this.context.getWorkspace().ObjectID;
    },

    _isPrefValueInStore: function (pref) {
        return this.store.findRecord(this.valueField, pref);
    }
});
Ext.define('CA.techservices.ToggleButton', {
    extend: Ext.Container ,
    alias:'widget.tstogglebutton',

    componentCls: 'rui-gridboard-toggle toggle-button-group',
    layout: 'hbox',
    border: 1,
    activeButtonCls: 'rly-active hide-tooltip',

    toggleState: 'Hours',

    defaultType: 'rallybutton',
    items: [
        {
            itemId: 'Hours',
            cls: 'toggle rly-left',
            frame: false,
            text: 'H',
            toolTipConfig: {
                html: 'Switch to Hours View',
                anchor: 'top',
                hideDelay: 0,
                constrainPosition: false,
                anchorOffset: 45,
                mouseOffset: [-45, 0]
            }
        },
        {
            itemId: 'Days',
            cls: 'toggle rly-right',
            frame: false,
            text: 'D',
            toolTipConfig: {
                html: 'Switch to Days View',
                anchor: 'top',
                hideDelay: 0,
                constrainPosition: false,
                anchorOffset: 65,
                mouseOffset: [-65, 0]
            }
        }
    ],

    initComponent: function() {
        this.callParent(arguments);

        this.addEvents([
            /**
             * @event toggle
             * Fires when the toggle value is changed.
             * @param {String} toggleState 'Hours' or 'Days'.
             */
            'toggle'
        ]);

        this.items.each(function(item) {
            this.mon(item, 'click', this._onButtonClick, this);
        }, this);

        this.down('#' + this.toggleState).addCls(this.activeButtonCls);
    },

    _onButtonClick: function(btn) {
        var btnId = btn.getItemId();
        if (btnId !== this.toggleState) {
            this.toggleState = btnId;

            this.items.each(function(item) {
                if (item === btn) {
                    if (!item.hasCls(this.activeButtonCls.split(' ')[0])) {
                        item.addCls(this.activeButtonCls);
                    }
                } else {
                    item.removeCls(this.activeButtonCls);
                }
            }, this);

            this.fireEvent('toggle', this, this.toggleState);
        }
    },
    
    getValue: function() {
        return this.toggleState;
    }
});
Ext.define("TSTimeInState", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    integrationHeaders: {
        name: "TSTimeInState"
    },
    defaults: { margin: 5 },
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    items: [
        {
            xtype: 'container',
            minHeight: 20,
            width: '100%',
            items: [{
                xtype: 'tabpanel',
                itemId: 'filterAndSettingsPanel',
                // stateful: true,
                // stateId: 'time-in-state-filter-and-settings-panel',
                header: false,
                collapsible: true,
                animCollapse: false,
                cls: 'blue-tabs',
                activeTab: 0,
                plain: true,
                tabBar: {
                    margin: '0 0 0 100'
                },
                autoRender: true,
                minTabWidth: 140,
                width: '100%',
                items: [
                    {
                        title: 'FILTERS',
                        html: '',
                        itemId: 'filtersTab',
                        padding: 5,
                        width: '100%',
                        items: [
                            {
                                id: Utils.AncestorPiAppFilter.RENDER_AREA_ID,
                                xtype: 'container',
                                layout: {
                                    type: 'hbox',
                                    align: 'middle',
                                    defaultMargins: '0 10 10 0',
                                },
                                width: '100%'
                            }, {
                                id: Utils.AncestorPiAppFilter.PANEL_RENDER_AREA_ID,
                                xtype: 'container',
                                layout: {
                                    type: 'hbox',
                                    align: 'middle',
                                    defaultMargins: '0 10 10 0',
                                },
                                width: '100%'
                            },
                        ]
                    },
                    {
                        title: 'Report Settings',
                        html: '',
                        itemId: 'settingsTab',
                        padding: 5,
                        defaultMargins: '5 10 0 0',
                        items: [{
                            xtype: 'container',
                            itemId: 'selector_box',
                            layout: 'hbox',
                            defaults: { margin: 10, layout: 'vbox' }
                        }]
                    },
                    {
                        title: 'Projects',
                        itemId: 'projectsTab',
                        padding: 10,
                    }
                ]
            }]
        },
        {
            xtype: 'container',
            itemId: 'button_bar',
            layout: {
                type: 'hbox',
                align: 'stretch',
                pack: 'end',
                defaultMargins: 2,
            },
            height: 28
        },
        {
            xtype: 'container',
            itemId: 'display_box',
            layout: {
                type: 'vbox',
                align: 'stretch',
                defaultMargins: 5,
            },
            flex: 1
        }
    ],

    launch: async function () {
        Rally.data.wsapi.Proxy.superclass.timeout = 180000;
        Rally.data.wsapi.batch.Proxy.superclass.timeout = 180000;
        this.settingsWidth = 220;
        this.labelWidth = 60;
        this.setLoading();
        this.addProjectPicker();
        this._setDisplayFormats();
        this.addCollapseBtn();

        if (this.getWidth() < 1024) {
            this.down('#selector_box').add([
                {
                    xtype: 'container',
                    layout: 'vbox',
                    items: [
                        { xtype: 'container', itemId: 'artifact_box' },
                        { xtype: 'container', itemId: 'state_selector_box' }
                    ]
                },
                {
                    xtype: 'container',
                    layout: 'vbox',
                    items: [
                        { xtype: 'container', itemId: 'date_selector_box' },
                        { xtype: 'container', itemId: 'metric_box', layout: 'column', align: 'center', width: 110 }
                    ]
                }
            ]);
        }
        else {
            this.down('#selector_box').add([
                { xtype: 'container', itemId: 'artifact_box' },
                { xtype: 'container', itemId: 'state_selector_box' },
                { xtype: 'container', itemId: 'date_selector_box' },
                { xtype: 'container', itemId: 'metric_box', layout: 'column', align: 'center', width: 110 }
            ]);
        }

        this.down('#display_box').on('resize', this.onGridAreaResize, this);

        // Hide floating components because of course they are still visible when settings menu is shown
        this.on('beforehide', () => {
            this.collapseBtn.hide();
        });
        this.on('beforeshow', () => {
            this.collapseBtn.show();

            if (this.down('#filterAndSettingsPanel').getActiveTab().title.indexOf('FILTERS') === -1) {
                setTimeout(() => this.ancestorFilterPlugin.hideHelpButton(), 1000);
            }
        });

        var filters = Rally.data.wsapi.Filter.or([
            { property: 'TypePath', operator: 'contains', value: 'PortfolioItem/' },
            { property: 'Name', value: 'Defect' },
            { property: 'Name', value: 'Hierarchical Requirement' }
        ]);

        this.down('#artifact_box').add({
            xtype: 'tsrecordtypecombobox',
            fieldLabel: 'Type',
            typeFilter: filters,
            margin: '0 5 10 0',
            width: this.settingsWidth,
            labelWidth: this.labelWidth,
            listeners: {
                scope: this,
                change: function (cb) {
                    if (this.process && this.process.getState().toLowerCase() === 'pending') {
                        this.process.cancel();
                    }

                    this.process = Deft.Chain.sequence([
                        function () { return this._getModel(cb.getValue()); }
                    ], this).then({
                        scope: this,
                        success: function (results) {
                            this.model = results[0];
                            this.model_name = cb.getValue();

                            this._addSelectors();
                        },
                        failure: function (msg) {
                            this.setLoading(false);
                            Ext.Msg.alert('', msg);
                        }
                    });
                }
            }
        });
        this._addMultiLevelFilters();
        this.setLoading(false);
    },

    onGridAreaResize() {
        let gridArea = this.down('#display_box');
        let grid = this.down('rallygrid');

        if (gridArea && grid) {
            grid.setHeight(gridArea.getHeight());
        }
    },

    addProjectPicker() {
        let tab = this.down('#filterAndSettingsPanel').child('#projectsTab');
        this.down('#projectsTab').add({
            xtype: 'customagileprojectpicker',
            cmp: this,
            appName: 'time-in-state',
            tab,
            listeners: {
                scope: this,
                projectschanged: () => {
                    this.refreshProjects = true;
                    this._clearGrid();
                },
                applyprojects: () => {
                    this._updateData();
                }
            }
        });

        this.projectPicker = this.down('customagileprojectpicker');
    },

    addCollapseBtn() {
        this.collapseBtn = Ext.widget('rallybutton', {
            text: this.down('#filterAndSettingsPanel').getCollapsed() ? 'Expand Filters and Settings' : 'Collapse',
            floating: true,
            shadow: false,
            height: 21,
            handler: (btn) => {
                this.down('#filterAndSettingsPanel').toggleCollapse();
                if (btn.getText() === 'Collapse') {
                    btn.setText('Expand Filters and Settings');
                    this.ancestorFilterPlugin.hideHelpButton();
                }
                else {
                    btn.setText('Collapse');
                    if (this.down('#filterAndSettingsPanel').getActiveTab().title.indexOf('FILTERS') > -1) {
                        this.ancestorFilterPlugin.showHelpButton();
                    }
                }
            }
        });

        this.collapseBtn.showBy(this.down('#filterAndSettingsPanel'), 'tl-tl', [0, 3]);
    },

    _addMultiLevelFilters: function () {
        this.ancestorFilterPlugin = Ext.create('Utils.AncestorPiAppFilter', {
            ptype: 'UtilsAncestorPiAppFilter',
            pluginId: 'ancestorFilterPlugin',
            settingsConfig: {},
            overrideGlobalWhitelist: true,
            whiteListFields: ['Tags', 'Milestones', 'c_EnterpriseApprovalEA', 'c_EAEpic', 'DisplayColor'],
            filtersHidden: false,
            displayMultiLevelFilter: true,
            visibleTab: this.model_name,
            listeners: {
                scope: this,
                ready(plugin) {
                    plugin.addListener({
                        scope: this,
                        select: this.filtersChange,
                        change: this.filtersChange
                    });
                    this.down('#filterAndSettingsPanel').on('beforetabchange', (tabs, newTab) => {
                        if (newTab.title.indexOf('FILTERS') > -1) {
                            this.ancestorFilterPlugin.showHelpButton();
                        }
                        else {
                            this.ancestorFilterPlugin.hideHelpButton();
                        }
                    });
                    this.down('#filterAndSettingsPanel').setActiveTab(1);
                    setTimeout(() => {
                        this.updateFilterTabText();
                        this.projectPicker.updateProjectTabText;
                    }, 600);
                },
                failure(msg) {
                    this.setLoading(false);
                    this.showError(msg, 'Failed to load multi-level filters');
                }
            }
        });
        this.addPlugin(this.ancestorFilterPlugin);
    },

    filtersChange() {
        this._clearGrid();
        this.updateFilterTabText();
    },

    updateFilterTabText(filters) {
        if (!filters) {
            filters = this.ancestorFilterPlugin.getMultiLevelFilters();
        }
        let totalFilters = 0;
        _.each(filters, function (filter) {
            totalFilters += filter.length;
        });

        let titleText = totalFilters ? `FILTERS (${totalFilters})` : 'FILTERS';
        let tab = this.down('#filterAndSettingsPanel').child('#filtersTab');

        if (tab) { tab.setTitle(titleText); }
    },

    async loadProjects() {
        this.setLoading('Loading Projects...');

        if (this.useSpecificProjects()) {
            await this._getSpecificProjectList();
        }
        else {
            await this._getScopedProjectList();
        }
    },

    async _getScopedProjectList() {
        let projectStore = Ext.create('Rally.data.wsapi.Store', {
            model: 'Project',
            fetch: ['Name', 'ObjectID', 'Children', 'Parent'],
            filters: [{ property: 'ObjectID', value: this.getContext().getProject().ObjectID }],
            limit: 1,
            pageSize: 1,
            autoLoad: false
        });

        let results = await projectStore.load();
        let parents = [];
        let children = [];
        if (results && results.length) {
            if (this.getContext().getProjectScopeDown()) {
                children = await this._getAllChildProjects(results);
            }

            if (this.getContext().getProjectScopeUp()) {
                parents = await this._getAllParentProjects(results[0]);
            }

            if (children.length) {
                results = children.concat(parents);
            }
            else if (parents.length) {
                results = parents;
            }

            this.projects = results;

            this.projectRefs = _.map(results, (p) => {
                return p.get('_ref');
            });
        }
        else {
            this.projects = [];
            this.projectRefs = [];
        }
    },

    async _getSpecificProjectList() {
        let projects = this.projectPicker.getValue();

        if (this.projectPicker.includeChildProjects()) {
            projects = await this._getAllChildProjects(projects);
        }

        this.projects = projects;

        this.projectRefs = _.map(projects, (p) => {
            return p.get('_ref');
        });
    },

    async _getAllChildProjects(allRoots = [], fetch = ['Name', 'Children', 'ObjectID']) {
        if (!allRoots.length) { return []; }

        const promises = allRoots.map(r => this.wrap(r.getCollection('Children', { fetch, limit: Infinity, filters: [{ property: 'State', value: 'Open' }] }).load()));
        const children = _.flatten(await Promise.all(promises));
        const decendents = await this._getAllChildProjects(children, fetch);
        const removeDupes = {};
        let finalResponse = _.flatten([...decendents, ...allRoots, ...children]);

        // eslint-disable-next-line no-return-assign
        finalResponse.forEach(s => removeDupes[s.get('_ref')] = s);
        finalResponse = Object.values(removeDupes);
        return finalResponse;
    },

    async _getAllParentProjects(p) {
        let projectStore = Ext.create('Rally.data.wsapi.Store', {
            model: 'Project',
            fetch: ['Name', 'ObjectID', 'Parent'],
            filters: [{ property: 'ObjectID', value: p.get('Parent').ObjectID }],
            limit: 1,
            pageSize: 1,
            autoLoad: false
        });

        let results = await projectStore.load();
        if (results && results.length) {
            if (results[0].get('Parent')) {
                let parents = await this._getAllParentProjects(results[0]);
                return [p].concat(parents);
            }
            return [p, results[0]];
        }
        return [p];
    },

    async wrap(deferred) {
        if (!deferred || !_.isFunction(deferred.then)) {
            return Promise.reject(new Error('Wrap cannot process this type of data into a ECMA promise'));
        }
        return new Promise((resolve, reject) => {
            deferred.then({
                success(...args) {
                    resolve(...args);
                },
                failure(error) {
                    reject(error);
                },
                scope: this
            });
        });
    },

    _setDisplayFormats: function () {
        var user_context = this.getContext().getUser();

        this.dateFormat = user_context.UserProfile.DateFormat;
        this.timeFormat = user_context.UserProfile.DateTimeFormat;

        if (Ext.isEmpty(this.dateFormat)) {
            this.dateFormat = this.getContext().getWorkspace().WorkspaceConfiguration.DateFormat;
        }

        if (Ext.isEmpty(this.timeFormat)) {
            this.timeFormat = this.getContext().getWorkspace().WorkspaceConfiguration.DateTimeFormat;
        }

        this.timeFormat = this.timeFormat.replace(/z/, '');

        return;
    },

    _clearBoxes: function (containers) {
        Ext.Array.each(containers, function (container) {
            container.removeAll();
        });
    },

    _addSelectors: function () {
        var field_chooser_box = this.down('#artifact_box');
        var state_chooser_box = this.down('#state_selector_box');
        var date_chooser_box = this.down('#date_selector_box');
        var button_bar = this.down('#button_bar');
        var metric_box = this.down('#metric_box');
        var context = this.getContext();

        this._clearBoxes([state_chooser_box, metric_box,
            date_chooser_box, button_bar]);

        if (this.down('rallyfieldcombobox')) {
            this.down('rallyfieldcombobox').destroy();
        }

        field_chooser_box.add({
            xtype: 'rallyfieldcombobox',
            model: this.model,
            _isNotHidden: this._isNotHidden,
            fieldLabel: 'State Field',
            width: this.settingsWidth,
            margin: '0 5 10 0',
            labelWidth: this.labelWidth,
            stateful: true,
            stateId: this.getModelScopedStateId(this.model.typePath, 'techservices-timeinstate-fieldcombo'),
            stateEvents: ['change'],
            listeners: {
                scope: this,
                change: function (cb) {
                    this._addStateSelectors(state_chooser_box, cb.getValue());
                }
            }
        });

        this._addDateSelectors(date_chooser_box);

        metric_box.add({
            xtype: 'rallycombobox',
            itemId: 'columnDetailCombo',
            fieldLabel: 'Columns',
            width: this.settingsWidth,
            labelSeparator: '',
            labelWidth: this.labelWidth,
            stateful: true,
            stateId: this.getModelScopedStateId(this.model.typePath, 'techservices-timeinstate-column-detail-combo'),
            stateEvents: ['change'],
            displayField: 'name',
            valueField: 'value',
            editable: false,
            allowBlank: false,
            store: Ext.create('Ext.data.Store', {
                fields: ['name', 'value'],
                data: [
                    { name: 'Time In State', value: 'timeOnly' },
                    { name: 'Time In State And Enter/Exit Dates', value: 'timeAndDates' }
                ]
            }),
            listeners: {
                scope: this,
                change: function () {
                    this._clearGrid();
                }
            }
        });

        metric_box.add({
            xtype: 'rallycombobox',
            itemId: 'metricCombo',
            fieldLabel: 'Format',
            width: this.settingsWidth,
            labelSeparator: '',
            labelWidth: this.labelWidth,
            stateful: true,
            stateId: this.getModelScopedStateId(this.model.typePath, 'techservices-timeinstate-metric-combo'),
            stateEvents: ['change'],
            displayField: 'name',
            valueField: 'value',
            editable: false,
            allowBlank: false,
            store: Ext.create('Ext.data.Store', {
                fields: ['name', 'value'],
                data: [
                    { name: 'Days', value: 'Days' },
                    { name: 'Weeks', value: 'Weeks' },
                ]
            }),
            listeners: {
                scope: this,
                change: function (cb, newVal) {
                    if (newVal === 'Days' && this.down('#excludeWeekendsCheckbox')) {
                        this.down('#excludeWeekendsCheckbox').show();
                    }
                    else if (newVal === 'Weeks' && this.down('#excludeWeekendsCheckbox')) {
                        this.down('#excludeWeekendsCheckbox').hide();
                    }
                    this._clearGrid();
                }
            }
        });

        metric_box.add({
            xtype: 'rallycheckboxfield',
            fieldLabel: 'Exclude Weekends',
            labelSeparator: '',
            itemId: 'excludeWeekendsCheckbox',
            width: this.settingsWidth,
            labelWidth: this.settingsWidth - 20,
            margin: '3 0 0 0',
            stateful: true,
            // hidden: this.down('#metricCombo').getValue() !== 'Days',
            stateId: this.getModelScopedStateId(this.model.typePath, 'techservices-timeinstate-exclude-weekends-checkbox'),
            stateEvents: ['change']
        });

        button_bar.add({
            xtype: 'tsfieldpickerbutton',
            context,
            modelNames: [this.model.typePath],
            cls: 'secondary rly-small',
            margin: '0 30 0 0',
            height: 26,
            toolTipConfig: {
                html: 'Additional Columns',
                anchor: 'top'
            },
            alwaysSelectedValues: [],
            stateful: true,
            stateId: this.getModelScopedStateId(this.model.typePath, 'techservices-timeinstate-fieldpickerbutton'),
            listeners: {
                fieldsupdated: function () {
                    this._clearGrid();
                },
                scope: this
            }
        });

        button_bar.add({
            xtype: 'rallybutton',
            itemId: 'updateBtn',
            text: 'Update',
            cls: 'primary rly-small',
            height: 26,
            padding: 3,
            margin: '0 30 0 0',
            listeners: {
                scope: this,
                click: this._updateData
            }
        });

        button_bar.add({
            xtype: 'rallybutton',
            itemId: 'export_button',
            cls: 'secondary rly-small',
            text: '<span class="icon-export"> </span>',
            height: 26,
            margin: '0 30 0 0',
            disabled: true,
            listeners: {
                scope: this,
                click: function () {
                    this._export();
                }
            }
        });

        button_bar.add({
            xtype: 'rallybutton',
            cls: 'customagile-button help',
            iconOnly: true,
            iconCls: 'icon-help',
            handler: this._onHelpClicked,
            id: 'timeInStateHelp',
            margin: '0 0 0 5'
        });

        setTimeout(() => {
            if (this.down('#metricCombo') && this.down('#metricCombo').getValue() !== 'Days') {
                this.down('#excludeWeekendsCheckbox').hide();
            }
        }, 400);
    },

    _addStateSelectors: function (container, fieldName) {
        container.removeAll();
        this.stateFieldName = fieldName;

        container.add({
            xtype: 'rallyfieldvaluecombobox',
            model: this.model,
            itemId: 'start_state_selector',
            margin: '0 5 10 0',
            field: fieldName,
            fieldLabel: 'Start State',
            width: this.settingsWidth,
            labelWidth: this.labelWidth,
            stateful: true,
            stateEvents: ['change'],
            stateId: this.getModelScopedStateId(this.model.typePath, 'techservices-timeinstate-startstatecombo')
        });

        container.add({
            xtype: 'rallyfieldvaluecombobox',
            model: this.model,
            itemId: 'end_state_selector',
            field: fieldName,
            fieldLabel: 'End State',
            width: this.settingsWidth,
            labelWidth: this.labelWidth,
            stateful: true,
            stateEvents: ['change'],
            stateId: this.getModelScopedStateId(this.model.typePath, 'techservices-timeinstate-endstatecombo')
        });

        container.add({
            xtype: 'rallycheckboxfield',
            fieldLabel: 'Include Blocked Time For Each State',
            labelSeparator: '',
            itemId: 'includeBlockedTimeCheckbox',
            width: this.settingsWidth,
            labelWidth: this.settingsWidth - 20,
            margin: '3 0 0 0',
            stateful: true,
            stateId: this.getModelScopedStateId(this.model.typePath, 'techservices-timeinstate-include-blocked-time-checkbox'),
            stateEvents: ['change']
        });
    },

    _addDateSelectors: function (container) {
        container.removeAll();

        container.add({
            xtype: 'rallydatefield',
            itemId: 'start_date_selector',
            margin: '0 5 10 0',
            fieldLabel: 'Start Date',
            allowBlank: false,
            width: this.settingsWidth,
            labelWidth: this.labelWidth,
            labelSeparator: '',
            stateful: true,
            stateEvents: ['change'],
            stateId: this.getModelScopedStateId(this.model.typePath, 'techservices-timeinstate-startdatecombo')
        });

        container.add({
            xtype: 'rallydatefield',
            itemId: 'end_date_selector',
            fieldLabel: 'End Date',
            width: this.settingsWidth,
            labelWidth: this.labelWidth,
            labelSeparator: '',
            margin: '0 5 10 0',
            stateful: true,
            stateEvents: ['change'],
            stateId: this.getModelScopedStateId(this.model.typePath, 'techservices-timeinstate-enddatecombo')
        });
    },


    _isNotHidden: function (field) {
        if (field.hidden) {
            return false;
        }
        var attributeDefn = field.attributeDefinition;

        if (Ext.isEmpty(attributeDefn)) {
            return false;
        }

        if (field.name == "State") {
            return true;
        }

        if (attributeDefn.AttributeType == "STATE") {
            return true;
        }

        if (attributeDefn.AttributeType == "STRING" && attributeDefn.Constrained == true) {
            return true;
        }

        return false;
    },

    onTimeboxScopeChange: function () {
        this.callParent(arguments);
        this._clearGrid();
    },

    _clearGrid: function () {
        var container = this.down('#display_box');
        let exportBtn = this.down('#export_button');
        if (container && exportBtn) {
            exportBtn.setDisabled(true);
            container.removeAll();
        }
    },

    _updateData: async function () {
        this._clearGrid();
        var fieldName = this.stateFieldName;

        this.startState = this.down('#start_state_selector').getValue();
        this.endState = this.down('#end_state_selector').getValue();
        if (fieldName == "State" && /Portfolio/.test(this.model_name)) {
            this.startState = this.down('#start_state_selector').getRecord().get('name');
            this.endState = this.down('#end_state_selector').getRecord().get('name');
        }
        this.startDate = this.down('#start_date_selector').getValue();
        this.endDate = this.down('#end_date_selector').getValue();

        if (!this.startDate) {
            this.showError('Start date is required');
            return;
        }

        if (Ext.isEmpty(this.startState) || Ext.isEmpty(this.endState)) {
            this.showError('Start and End States are required');
            return;
        }

        try {
            this._setValidStates();
            let snapshots = await this._getChangeSnapshots(fieldName);
            let snaps_by_oid = this._organizeSnapshotsByOid(snapshots);
            let rows_by_oid = this._setTimeInStatesForAll(snaps_by_oid, fieldName);
            let rows = Ext.Object.getValues(rows_by_oid);
            rows = this._removeItemsOutsideTimeboxes(rows);
            rows = await this._syncWithCurrentData(rows);

            if (rows) {
                this._makeGrid(rows);
            }
            this.setLoading(false);
        }
        catch (e) {
            this.setLoading(false);
            this.showError(e);
        }
    },

    _syncWithCurrentData: async function (rows) {
        if (!rows.length) {
            return rows;
        }

        let fetch = ['ObjectID', 'FormattedID', 'Name', 'Project', 'Value'];
        fetch = fetch.concat(this.getAdditionalFieldsFromButton());

        let records = await this._getCurrentDataWithFilters(rows, fetch);

        if (!records) {
            throw new Error('Failed while loading records. Result set might be too large.');
        }

        rows = _.filter(rows, (r) => {
            for (let record of records) {
                if (record.get('ObjectID') === r.ObjectID) {
                    for (let f of fetch) {
                        if (f === 'Project') {
                            r.__ProjectName = record.get(f).Name;
                        }
                        else {
                            r[f] = CustomAgile.ui.renderer.RecordFieldRendererFactory.getFieldDisplayValue(record, f, '; ', true);
                        }
                    }
                    return true;
                }
            }
            return false;
        });
        return rows;
    },

    _shouldFilterByTimebox: function () {
        let timeboxScope = this.getContext().getTimeboxScope();
        if (timeboxScope) {
            let type = timeboxScope.type;
            let model = this._getModelName().toLowerCase();
            if (type === 'iteration' && model.indexOf('portfolioitem') > -1) {
                return false;
            }
            else if (model.indexOf('portfolioitem') > -1 && model.indexOf('feature') === -1) {
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    },

    _getCurrentDataWithFilters: async function (rows, fetch) {
        this.setLoading('Loading filters and column data');

        let context = this.getContext().getDataContext();
        let ids = _.map(rows, r => r.ObjectID);
        let filters = await this.ancestorFilterPlugin.getAllFiltersForType(this._getModelName(), true);

        if (this.searchAllProjects()) {
            context.project = null;
        } else if (this.useSpecificProjects() && this.projectRefs && this.projectRefs.length > 0) {
            context.project = null;
            filters.push(new Rally.data.wsapi.Filter({
                property: 'Project',
                operator: 'in',
                value: this.projectRefs
            }));
        }

        if (this._shouldFilterByTimebox()) {
            let timeboxScope = this.getContext().getTimeboxScope();
            if (timeboxScope) {
                filters.push(timeboxScope.getQueryFilter());
            }
        }

        filters.push(new Rally.data.wsapi.Filter({
            property: 'ObjectID',
            operator: 'in',
            value: ids
        }));

        var config = {
            model: this._getModelName(),
            filters,
            fetch,
            context,
            limit: 6000,
            enablePostGet: true
        };

        let records;
        try {
            records = await this._loadWsapiRecords(config);
        } catch (e) { };

        this.setLoading(false);

        return records;
    },

    _removeItemsOutsideTimeboxes: function (rows) {
        if (Ext.isEmpty(this.startDate) && Ext.isEmpty(this.endDate)) {
            return rows;
        }

        var states = this._getShowStates(this.allowedStates, this.startState, this.endState);
        var filtered_rows = this._getRowsAfter(rows, this.startDate, states);
        filtered_rows = this._getRowsBefore(filtered_rows, this.endDate, states);
        return filtered_rows;
    },

    _getRowsAfter: function (rows, start_date, states) {
        if (Ext.isEmpty(start_date)) {
            return rows;
        }

        // let enter_field = 'firstEntry_' + this.startState;
        let start = Rally.util.DateTime.toIsoString(start_date);

        return Ext.Array.filter(rows, function (row) {
            for (let state of states) {
                let enter_field = 'firstEntry_' + state;
                if (row[enter_field] && row[enter_field] >= start) {
                    return true;
                }
            }
            return false;
            // var enter = row[enter_field];
            // if (Ext.isEmpty(enter)) {
            //     return false;
            // }
            // return (Rally.util.DateTime.toIsoString(start_date) <= enter);
        });
    },

    _getRowsBefore: function (rows, end_date, states) {
        if (Ext.isEmpty(end_date)) {
            return rows;
        }

        // let enter_field = 'firstEntry_' + this.startState;
        let end = Rally.util.DateTime.toIsoString(end_date);

        return Ext.Array.filter(rows, function (row) {
            for (let state of states) {
                let enter_field = 'firstEntry_' + state;
                if (row[enter_field] && row[enter_field] <= end) {
                    return true;
                }
            }
            return false;
            // var enter = row[enter_field];
            // if (Ext.isEmpty(enter)) {
            //     return false;
            // }
            // return (Rally.util.DateTime.toIsoString(start_date) <= enter);
        });
        // var enter_field = 'firstEntry_' + this.startState;

        // return Ext.Array.filter(rows, function (row) {
        //     var enter = row[enter_field];
        //     if (Ext.isEmpty(enter)) {
        //         return false;
        //     }
        //     return (Rally.util.DateTime.toIsoString(end_date) >= enter);
        // });
    },

    _setTimeInStatesForAll: function (snaps_by_oid, fieldName) {
        var rows_by_oid = {};
        var me = this;
        var includeBlocked = this.includeBlocked();
        Ext.Object.each(snaps_by_oid, function (key, snaps) {
            rows_by_oid[key] = me._calculateTimeInState(snaps, fieldName, includeBlocked);
        });
        return rows_by_oid;
    },

    _calculateTimeInState: function (snapshots, fieldName, includeBlocked) {
        var entries = {};  // date of entry into state, used for calc
        var last_index = snapshots.length - 1;
        var excludeWeekends = this.down('#excludeWeekendsCheckbox').getValue();
        var format = this.down('#metricCombo').getValue();
        var row = Ext.Object.merge({
            snapshots: snapshots,
            __ProjectName: snapshots[last_index].get('__ProjectName'),
            __Project: snapshots[last_index].get('__Project')
        },
            snapshots[last_index].getData()
        );

        // Initialize data points for each state
        Ext.Array.each(this.allowedStates, function (state) {
            row[state] = 0;
            entries[state] = null;
            row['firstEntry_' + state] = null;
            row['lastExit_' + state] = null;

            if (includeBlocked) {
                row[state + '_blocked'] = 0;
                entries[state + '_blocked'] = null;
                row['firstEntry_' + state + '_blocked'] = null;
                row['lastExit_' + state + '_blocked'] = null;
            }
        }.bind(this));

        Ext.Array.each(snapshots, function (snap) {
            let fromState = snap.get('_PreviousValues.' + fieldName);
            let toState = snap.get(fieldName);
            let snapTime = snap.get('_ValidFrom');
            let isBlocked = snap.get('Blocked');
            let blockedChanged = typeof snap.get('Blocked') === 'boolean' && typeof snap.get('_PreviousValues.Blocked') === 'boolean';

            // For each snapshot, _PreviousValues will only contain fields that experienced a change at the exact time of the snapshot
            // This will tell us whether the snapshot was taken due to a state change or a Blocked change or both
            if (includeBlocked && blockedChanged) {
                if (isBlocked) {
                    // Note the time the artifact became blocked
                    entries[toState + '_blocked'] = snapTime;
                }
                else {
                    // If state was changed at the same time
                    if (fromState) {
                        if (entries[fromState + '_blocked']) {
                            // Add the duration of blocked time to the previous state
                            let delta = this._getTimeDelta(entries[fromState + '_blocked'], snapTime, excludeWeekends, format);
                            row[fromState + '_blocked'] += delta;
                            entries[fromState + '_blocked'] = null;
                        }
                    }
                    // Same state as before
                    else {
                        if (entries[toState + '_blocked']) {
                            // Add the duration of blocked time to the current state
                            let delta = this._getTimeDelta(entries[toState + '_blocked'], snapTime, excludeWeekends, format);
                            row[toState + '_blocked'] += delta;
                            entries[toState + '_blocked'] = null;
                        }
                    }
                }
            }

            if (fromState) {
                if (includeBlocked) {
                    // Case where artifact was already blocked and then entered a new state
                    if (isBlocked && !blockedChanged) {
                        entries[toState + '_blocked'] = snapTime;
                        if (entries[fromState + '_blocked']) {
                            let delta = this._getTimeDelta(entries[fromState + '_blocked'], snapTime, excludeWeekends, format);
                            row[fromState + '_blocked'] += delta;
                            entries[fromState + '_blocked'] = null;
                        }
                    }
                }

                entries[toState] = snapTime;
                row['lastExit_' + toState] = null; // clear out for re-entry

                if (Ext.isEmpty(row['firstEntry_' + toState])) {
                    row['firstEntry_' + toState] = snapTime;
                }

                if (!Ext.isEmpty(entries[fromState])) {
                    let delta = this._getTimeDelta(entries[fromState], snapTime, excludeWeekends, format);
                    row[fromState] += delta;
                    row['lastExit_' + fromState] = snapTime;
                }
            }
        }.bind(this));

        // Add time to the current state of each row
        Ext.Array.each(this.allowedStates, function (state) {
            if (row['firstEntry_' + state] && !row['lastExit_' + state] && entries[state]) {
                let delta = this._getTimeDelta(entries[state], Rally.util.DateTime.toIsoString(new Date()), excludeWeekends, format);
                row[state] = row[state] + delta;
            }
            else if (!row['firstEntry_' + state] && !row['lastExit_' + state]) {
                row[state] = '';
                if (includeBlocked) {
                    row[state + '_blocked'] = '';
                }
            }

            if (includeBlocked && entries[state + '_blocked']) {
                let delta = this._getTimeDelta(entries[state + '_blocked'], Rally.util.DateTime.toIsoString(new Date()), excludeWeekends, format);
                row[state + '_blocked'] = row[state + '_blocked'] + delta;
            }
        }.bind(this));

        return row;
    },

    _getTimeDelta: function (start, end, excludeWeekends, format) {
        if (excludeWeekends && format === 'Days') {
            let delta = moment().isoWeekdayCalc(start, end, [1, 2, 3, 4, 5]);
            if (delta) { delta--; }
            return delta * 1440;
        }
        else {
            var jsStart = Rally.util.DateTime.fromIsoString(start);
            var jsEnd = Rally.util.DateTime.fromIsoString(end);
            return Rally.util.DateTime.getDifference(jsEnd, jsStart, 'minute');
        }
    },

    _getModelName: function () {
        return this.model_name;
    },

    _setValidStates: function () {
        var store = this.down('rallyfieldvaluecombobox').getStore();
        var count = store.getTotalCount();

        var values = [];
        for (var i = 0; i < count; i++) {
            var value = store.getAt(i);

            if (!Ext.isEmpty(value.get('value'))) {
                values.push(value.get('name'));
            }
        }
        this.allowedStates = values;

        return values;
    },

    _organizeSnapshotsByOid: function (snapshots) {
        var snapshots_by_oid = {};

        Ext.Array.each(snapshots, function (snap) {
            var oid = snap.get('ObjectID');
            if (Ext.isEmpty(snapshots_by_oid[oid])) {
                snapshots_by_oid[oid] = [];
            }

            snapshots_by_oid[oid].push(snap);
        });

        return snapshots_by_oid;
    },

    _getChangeSnapshots: async function (fieldName) {
        var filters = Ext.create('Rally.data.lookback.QueryFilter', {
            property: '_TypeHierarchy',
            value: this._getModelName()
        });


        if (!this.searchAllProjects() && (!this.projects || this.refreshProjects)) {
            await this.loadProjects();
            this.refreshProjects = false;
        }
        filters = filters.and(Ext.create('Rally.data.lookback.QueryFilter', {
            property: 'Project',
            operator: 'in',
            value: _.map(this.projects, p => p.get('ObjectID'))
        }));

        let endFilter = Ext.create('Rally.data.lookback.QueryFilter', {
            property: '_ValidTo',
            operator: '>=',
            value: Rally.util.DateTime.toIsoString(this.startDate)
        });

        let change_filters = Ext.create('Rally.data.lookback.QueryFilter', {
            property: '_PreviousValues.' + fieldName,
            operator: 'exists',
            value: true
        });

        var fetch_base = ['ObjectID', 'FormattedID',
            'Project', '_TypeHierarchy', '_PreviousValues',
            fieldName, '_PreviousValues.' + fieldName, '_ValidFrom', '_ValidTo'];

        if (this.includeBlocked()) {
            fetch_base = fetch_base.concat(['Blocked', '_PreviousValues.Blocked']);
            let blocked_filters = Ext.create('Rally.data.lookback.QueryFilter', {
                property: '_PreviousValues.Blocked',
                operator: 'exists',
                value: true
            });

            change_filters = change_filters.or(blocked_filters);
        }

        endFilter = endFilter.and(change_filters);
        filters = filters.and(endFilter);

        var hydrate = ['_PreviousValues.' + fieldName, fieldName];

        var config = {
            filters,
            fetch: fetch_base,
            hydrate,
            limit: Infinity,
            enablePostGet: true,
            useHttpPost: true,
            compress: true,
            removeUnauthorizedSnapshots: true
        };

        this.setLoading('Loading Historical Snapshots...');

        return this.wrap(Ext.create('Rally.data.lookback.SnapshotStore', config).load());
    },

    includeBlocked: function () {
        return this.down('#includeBlockedTimeCheckbox').getValue();
    },

    _getModel: function (model_name) {
        var deferred = Ext.create('Deft.Deferred');
        Rally.data.ModelFactory.getModel({
            type: model_name,
            success: function (model) {
                deferred.resolve(model);
            },
            failure: function () {
                this.setLoading(false);
                deferred.reject('cannot load model');
            }
        });
        return deferred.promise;
    },

    getAdditionalFieldsFromButton: function () {
        var fieldPicker = this.down('tsfieldpickerbutton');
        var result = [];
        if (fieldPicker) {
            result = fieldPicker.getFields();
        }
        return result;
    },

    _loadWsapiRecords: function (config) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        var default_config = {
            model: 'Defect',
            fetch: ['ObjectID']
        };
        Ext.create('Rally.data.wsapi.Store', Ext.Object.merge(default_config, config)).load({
            callback: function (records, operation, successful) {
                if (successful) {
                    deferred.resolve(records);
                } else {
                    me.setLoading(false);
                    if (operation.error && operation.error.errors) {
                        deferred.reject('Problem loading: ' + operation.error.errors.join('. '));
                    }
                    else {
                        deferred.reject('Unkown error while fetching historical snapshots. Filtered result set might be too large.');
                    }
                }
            }
        });
        return deferred.promise;
    },

    _makeGrid: function (rows) {
        this.rows = rows;
        this.down('#export_button').setDisabled(false);

        var container = this.down('#display_box');
        var store = Ext.create('Rally.data.custom.Store', { data: rows });

        container.add({
            xtype: 'rallygrid',
            store: store,
            columnCfgs: this._getColumns(),
            showRowActionsColumn: false,
            height: container.getHeight()
        });
    },

    _getShowStates: function (allowed_states, start_state, end_state) {
        var start_index = Ext.Array.indexOf(allowed_states, start_state);
        var end_index = Ext.Array.indexOf(allowed_states, end_state);

        // swap if chosen out of order
        if (start_index > end_index) {
            var holder = start_index;
            start_index = end_index;
            end_index = holder;
        }

        return (
            Ext.Array.filter(allowed_states, function (state, idx) {
                return (idx >= start_index && idx <= end_index);
            })
        );
    },

    _getPickableColumns: function () {
        var blacklist = ['Attachments', 'Changesets', 'Collaborators', 'Connections', 'Discussion', 'Risks', 'UserStories', 'Children', 'Defects', 'Tasks', 'TestCases', 'RevisionHistory', 'c_SalesforceCase'];

        var filtered_fields = Ext.Array.filter(this.model.getFields(), function (field) {
            if (field.hidden) {
                return false;
            }

            if (_.contains(blacklist, field.name)) {
                return false;
            }

            if (field.name == "FormattedID" || field.name == "Name") {
                return false;
            }

            if (field.name == "Iteration" || field.name == "Release") {
                return true;
            }

            var attributeDefn = field.attributeDefinition;
            if (Ext.isEmpty(attributeDefn)) {
                return false;
            }

            return true;
        });

        var object_renderer = function (value, meta, record) {
            if (Ext.isEmpty(value)) { return ""; }
            if (Ext.isObject(value)) { return value.Name || value.DisplayName; }

            return value;
        }

        return Ext.Array.map(filtered_fields, function (field) {
            return {
                dataIndex: field.name,
                text: field.displayName,
                hidden: true,
                renderer: object_renderer
            };
        });
    },

    _getColumns: function () {
        var me = this;
        var includeBlocked = this.includeBlocked();
        var metric = me.down('#metricCombo').getValue();
        var showDateColumns = this.down('#columnDetailCombo').getValue() === 'timeAndDates';
        var columns = [
            { dataIndex: 'FormattedID', text: 'id', width: 75 },
            { dataIndex: 'Name', text: 'Name', width: 200 },
            { dataIndex: '__ProjectName', text: 'Project', width: 155 }
        ];

        columns = columns.concat(_.map(this.getAdditionalFieldsFromButton(), c => { return { dataIndex: c, text: c }; }));
        var show_states = this._getShowStates(this.allowedStates, this.startState, this.endState);

        var date_renderer = function (value, meta, record) {
            if (Ext.isEmpty(value)) { return ""; }

            if (Ext.isString(value)) {
                value = Rally.util.DateTime.fromIsoString(value);
            }

            var format = me.timeFormat;
            if (metric === 'Days' || metric === 'Weeks') {
                format = me.dateFormat;
            }
            return Rally.util.DateTime.format(value, format);
        };


        Ext.Array.each(show_states, function (state) {
            columns.push({
                dataIndex: state,
                text: Ext.String.format('{0} ({1})', state, metric),
                align: 'right',
                renderer: function (value) {
                    if (Ext.isEmpty(value)) { return ""; }
                    let minutes = metric === 'Weeks' ? 10080 : 1440;
                    return Ext.Number.toFixed(value / minutes, 1);
                }
            });

            if (showDateColumns) {
                columns.push({
                    dataIndex: 'firstEntry_' + state,
                    text: state + ' first entered',
                    align: 'right',
                    renderer: date_renderer
                });

                columns.push({
                    dataIndex: 'lastExit_' + state,
                    text: state + ' last exited',
                    align: 'right',
                    renderer: date_renderer
                });
            }

            if (includeBlocked) {
                columns.push({
                    dataIndex: state + '_blocked',
                    text: Ext.String.format('{0} {1} ({2})', state, 'Blocked', metric),
                    align: 'right',
                    renderer: function (value) {
                        if (Ext.isEmpty(value)) { return ""; }
                        let minutes = metric === 'Weeks' ? 10080 : 1440;
                        return Ext.Number.toFixed(value / minutes, 1);
                    }
                });
            }
        });

        return columns;
    },

    searchAllProjects() {
        return this.ancestorFilterPlugin && this.ancestorFilterPlugin.getIgnoreProjectScope();
    },

    useSpecificProjects() {
        return !!this.projectPicker.getValue().length;
    },

    _export: function () {
        var me = this;
        var grid = this.down('rallygrid');
        var rows = this.rows;

        if (!grid && !rows) { return; }

        var filename = 'time-in-state-report.csv';
        this.setLoading("Generating CSV");
        Deft.Chain.sequence([
            function () { return Rally.technicalservices.FileUtilities.getCSVFromRows(this, grid, rows); }
        ]).then({
            scope: this,
            success: function (csv) {
                if (csv && csv.length > 0) {
                    Rally.technicalservices.FileUtilities.saveCSVToFile(csv, filename);
                } else {
                    Rally.ui.notify.Notifier.showWarning({ message: 'No data to export' });
                }

            }
        }).always(function () { me.setLoading(false); });
    },

    getModelScopedStateId(modelName, id) {
        return this.getContext().getScopedStateId(`${modelName}-${id}`);
    },

    getOptions: function () {
        return [
            {
                text: 'About...',
                handler: this._launchInfo,
                scope: this
            }
        ];
    },

    _launchInfo: function () {
        if (this.about_dialog) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink', {});
    },

    isExternal: function () {
        return typeof (this.getAppId()) == 'undefined';
    },

    getSettingsFields: function () {
        return [{
            xtype: 'text',
            text: ''
        }];
    },

    //onSettingsUpdate:  Override
    onSettingsUpdate: function (settings) {
        this.launch();
    },

    showError(msg, defaultMessage) {
        if (typeof msg === 'object') {
            console.log(msg);
        }
        Rally.ui.notify.Notifier.showError({ message: this.parseError(msg, defaultMessage) });
    },

    parseError(e, defaultMessage) {
        defaultMessage = defaultMessage || 'An unknown error has occurred';

        if (typeof e === 'string' && e.length) {
            return e;
        }
        if (e.message && e.message.length) {
            return e.message;
        }
        if (e.exception && e.error && e.error.errors && e.error.errors.length) {
            if (e.error.errors[0].length) {
                return e.error.errors[0];
            } else {
                if (e.error && e.error.response && e.error.response.status) {
                    return `${defaultMessage} (Status ${e.error.response.status})`;
                }
            }
        }
        if (e.exceptions && e.exceptions.length && e.exceptions[0].error) {
            return e.exceptions[0].error.statusText;
        }
        return defaultMessage;
    },


    _onHelpClicked: function () {
        CustomAgile.ui.tutorial.TimeInStateTutorial.showWelcomeDialog(Rally.getApp());
    }
});

            
               Rally.launchApp('TSTimeInState', {
                   name: 'TS Time In State'
               });
        });
    </script>
    
    <style type="text/css">

.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}


.help .x-btn-button {
    height: 18px !important;
    width: 18px !important;
  }

.icon-help {
    font-size: 16px;
    text-align: center;
    color: #327c98 !important;
}

.icon-help:hover {
    color: #21516d !important;
}

.customagile-button.help {
    padding: 2px 0 0 15px;
}

.helpText p {
    margin-block-start: 0.5em;
}

.helpText h3 {
    margin-block-end: 0;
}

.apply-filters-button {
  background-color: #75c63f;
}
.multiselect-timebox-picker .rui-picker-option-text {
  display: flex;
  flex-direction: row;
  margin-left: 5px;
}

.timebox-dates {
  display: flex;
  flex-direction: row;
  margin-left: auto;
}

.pill-select-container .tagPill {
  font-size: 9px;
  padding: 1px 20px 1px 5px;
  cursor: pointer;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.x-form-trigger-click {
  cursor: pointer;
}
.blue-tabs .x-tab-bar .x-tab-default {
  background-color: white;
  border-radius: 4px 4px 0 0;
}

.blue-tabs .x-tab-bar .x-tab-default .x-tab-inner {
  color: #00a9e0;
}

.blue-tabs .x-tab-bar .x-tab-active {
  background-color: #00a9e0;
}

.blue-tabs .x-tab-bar .x-tab-active .x-tab-inner {
  color: white;
}

.blue-tabs .x-tab-bar .x-tab-default .x-tab-inner {
  text-overflow: initial;
  -o-text-overflow: initial;
  overflow: initial;
}

.blue-tabs .x-tab-bar .x-tab-inner {
  width: 100%;
}

.blue-tabs .x-tab-bar .x-tab-default .x-tab-icon-el {
  color: white;
}

.filter-help { 
  border-color: #d6d6d6 !important;
}

.icon-help {
  font-size: 16px;
  text-align: center;
  color: #327c98 !important;
}

.icon-help:hover {
  color: #21516d !important;
}

.filter-help .x-btn-button {
  height: 18px !important;
  width: 18px !important;
}

.filter-help-list li{
  padding-bottom: 6px;
}
    </style>

</head>
<body></body>
</html>